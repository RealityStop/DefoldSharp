-- Compiled from https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Numerics/src/System/Numerics/Complex.cs
-- Generated by CSharp.lua Compiler
-- Licensed to the .NET Foundation under one or more agreements.
-- The .NET Foundation licenses this file to you under the MIT license.
-- See the LICENSE file in the project root for more information.
local System = System

local assert = assert
local type = type
local math = math

-- <summary>
-- A complex number z is a number of the form z = x + yi, where x and y
-- are real numbers, and i is the imaginary unit, with the property i2= -1.
-- </summary>
System.define("System.Numerics.Complex", (function ()
  local Zero, One, ImaginaryOne, NaN, Infinity, s_sqrtRescaleThreshold, s_asinOverflowThreshold, s_log2, 
  getReal, getImaginary, getMagnitude, getPhase, FromPolarCoordinates, Negate, Add, Subtract, 
  Multiply, Divide, Abs, Hypot, Log1P, Conjugate, Reciprocal, op_Equality, EqualsObj, Equals, 
  GetHashCode, ToString, Sin, Sinh, Asin, Cos, Cosh, Acos, 
  Tan, Tanh, Atan, Asin_Internal, IsFinite, IsInfinity, IsNaN, Log, 
  Log10, Exp, Sqrt, Pow, Pow1, Scale, ToComplex, 
  class, static, __ctor__
  static = function (this)
    Zero = class(0.0, 0.0)
    this.Zero = Zero
    One = class(1.0, 0.0)
    this.One = One
    ImaginaryOne = class(0.0, 1.0)
    this.ImaginaryOne = ImaginaryOne
    NaN = class(System.Double.NaN, System.Double.NaN)
    this.NaN = NaN
    Infinity = class(System.Double.PositiveInfinity, System.Double.PositiveInfinity)
    this.Infinity = Infinity
    s_sqrtRescaleThreshold = 1.79769313486232E+308 --[[Double.MaxValue]] / (math.Sqrt(2.0) + 1.0)
    s_asinOverflowThreshold = math.Sqrt(1.79769313486232E+308 --[[Double.MaxValue]]) / 2.0
    s_log2 = math.Log(2.0)
  end
  __ctor__ = function (this, real, imaginary)
    if real == nil then
      return
    end
    this.m_real = real
    this.m_imaginary = imaginary
  end
  getReal = function (this)
    return this.m_real
  end
  getImaginary = function (this)
    return this.m_imaginary
  end
  getMagnitude = function (this)
    return Abs(this)
  end
  getPhase = function (this)
    return math.Atan2(this.m_imaginary, this.m_real)
  end
  FromPolarCoordinates = function (magnitude, phase)
    return class(magnitude * math.Cos(phase), magnitude * math.Sin(phase))
  end
  Negate = function (value)
    return class(- value.m_real, - value.m_imaginary)
  end
  Add = function (left, right)
    if type(left) == "number" then
      return class(left + right.m_real, right.m_imaginary)
    elseif type(right) == "number" then
      return class(left.m_real + right, left.m_imaginary)
    else
      return class(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary)
    end
  end
  Subtract = function (left, right)
    if type(left) == "number" then
      return class(left - right.m_real, - right.m_imaginary)
    elseif type(right) == "number" then
      return class(left.m_real - right, left.m_imaginary)
    else
      return class(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary)
    end
  end
  Multiply = function (left, right)
    if type(left) == "number" then
      if not System.Double.IsFinite(right.m_real) then
        if not System.Double.IsFinite(right.m_imaginary) then
          return class(System.Double.NaN, System.Double.NaN)
        end

        return class(left * right.m_real, System.Double.NaN)
      end

      if not System.Double.IsFinite(right.m_imaginary) then
        return class(System.Double.NaN, left * right.m_imaginary)
      end

      return class(left * right.m_real, left * right.m_imaginary)
    elseif type(right) == "number" then
      if not System.Double.IsFinite(left.m_real) then
        if not System.Double.IsFinite(left.m_imaginary) then
          return class(System.Double.NaN, System.Double.NaN)
        end

        return class(left.m_real * right, System.Double.NaN)
      end

      if not System.Double.IsFinite(left.m_imaginary) then
        return class(System.Double.NaN, left.m_imaginary * right)
      end

      return class(left.m_real * right, left.m_imaginary * right)
    else
      -- Multiplication:  (a + bi)(c + di) = (ac -bd) + (bc + ad)i
      local result_realpart = (left.m_real * right.m_real) - (left.m_imaginary * right.m_imaginary)
      local result_imaginarypart = (left.m_imaginary * right.m_real) + (left.m_real * right.m_imaginary)
      return class(result_realpart, result_imaginarypart)
    end
  end
  Divide = function (left, right)
    if type(left) == "number" then
      -- Division : Smith's formula.
      local a = left
      local c = right.m_real
      local d = right.m_imaginary

      -- Computing c * c + d * d will overflow even in cases where the actual result of the division does not overflow.
      if math.Abs(d) < math.Abs(c) then
        local doc = d / c
        return class(a / (c + d * doc), (- a * doc) / (c + d * doc))
      else
        local cod = c / d
        return class(a * cod / (d + c * cod), - a / (d + c * cod))
      end
    elseif type(right) == "number" then
      -- IEEE prohibit optimizations which are value changing
      -- so we make sure that behaviour for the simplified version exactly match
      -- full version.
      if right == 0 then
        return class(System.Double.NaN, System.Double.NaN)
      end

      if not System.Double.IsFinite(left.m_real) then
        if not System.Double.IsFinite(left.m_imaginary) then
          return class(System.Double.NaN, System.Double.NaN)
        end

        return class(left.m_real / right, System.Double.NaN)
      end

      if not System.Double.IsFinite(left.m_imaginary) then
        return class(System.Double.NaN, left.m_imaginary / right)
      end

      -- Here the actual optimized version of code.
      return class(left.m_real / right, left.m_imaginary / right)
    else
      -- Division : Smith's formula.
      local a = left.m_real
      local b = left.m_imaginary
      local c = right.m_real
      local d = right.m_imaginary

      -- Computing c * c + d * d will overflow even in cases where the actual result of the division does not overflow.
      if math.Abs(d) < math.Abs(c) then
        local doc = d / c
        return class((a + b * doc) / (c + d * doc), (b - a * doc) / (c + d * doc))
      else
        local cod = c / d
        return class((b + a * cod) / (d + c * cod), (- a + b * cod) / (d + c * cod))
      end
    end
  end
  Abs = function (value)
    return Hypot(value.m_real, value.m_imaginary)
  end
  Hypot = function (a, b)
    -- Using
    --   sqrt(a^2 + b^2) = |a| * sqrt(1 + (b/a)^2)
    -- we can factor out the larger component to dodge overflow even when a * a would overflow.

    a = math.Abs(a)
    b = math.Abs(b)

    local small, large
    if a < b then
      small = a
      large = b
    else
      small = b
      large = a
    end

    if small == 0.0 then
      return large
    elseif System.Double.IsPositiveInfinity(large) and not System.Double.IsNaN(small) then
      -- The NaN test is necessary so we don't return +inf when small=NaN and large=+inf.
      -- NaN in any other place returns NaN without any special handling.
      return (System.Double.PositiveInfinity)
    else
      local ratio = small / large
      return (large * math.Sqrt(1.0 + ratio * ratio))
    end
  end
  Log1P = function (x)
    -- Compute log(1 + x) without loss of accuracy when x is small.

    -- Our only use case so far is for positive values, so this isn't coded to handle negative values.
    assert((x >= 0.0) or System.Double.IsNaN(x))

    local xp1 = 1.0 + x
    if xp1 == 1.0 then
      return x
    elseif x < 0.75 then
      -- This is accurate to within 5 ulp with any floating-point system that uses a guard digit,
      -- as proven in Theorem 4 of "What Every Computer Scientist Should Know About Floating-Point
      -- Arithmetic" (https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)
      return x * math.Log(xp1) / (xp1 - 1.0)
    else
      return math.Log(xp1)
    end
  end
  Conjugate = function (value)
    -- Conjugate of a Complex number: the conjugate of x+i*y is x-i*y
    return class(value.m_real, - value.m_imaginary)
  end
  Reciprocal = function (value)
    -- Reciprocal of a Complex number : the reciprocal of x+i*y is 1/(x+i*y)
    if value.m_real == 0 and value.m_imaginary == 0 then
      return Zero
    end
    return One / value
  end
  op_Equality = function (left, right)
    return left.m_real == right.m_real and left.m_imaginary == right.m_imaginary
  end
  EqualsObj = function (this, obj)
    if not (System.is(obj, class)) then
      return false
    end
    return Equals(this, System.cast(class, obj))
  end
  Equals = function (this, value)
    return this.m_real:Equals(value.m_real) and this.m_imaginary:Equals(value.m_imaginary)
  end
  GetHashCode = function (this)
    local n1 = 99999997
    local realHash = System.mod(this.m_real:GetHashCode(), n1)
    local imaginaryHash = this.m_imaginary:GetHashCode()
    local finalHash = System.xor(realHash, imaginaryHash)
    return finalHash
  end
  ToString = function (this)
    return ("(%s, %s)"):format(this.m_real, this.m_imaginary)
  end
  Sin = function (value)
    -- We need both sinh and cosh of imaginary part. To avoid multiple calls to Math.Exp with the same value,
    -- we compute them both here from a single call to Math.Exp.
    local p = math.Exp(value.m_imaginary)
    local q = 1.0 / p
    local sinh = (p - q) * 0.5
    local cosh = (p + q) * 0.5
    return class(math.Sin(value.m_real) * cosh, math.Cos(value.m_real) * sinh)
    -- There is a known limitation with this algorithm: inputs that cause sinh and cosh to overflow, but for
    -- which sin or cos are small enough that sin * cosh or cos * sinh are still representable, nonetheless
    -- produce overflow. For example, Sin((0.01, 711.0)) should produce (~3.0E306, PositiveInfinity), but
    -- instead produces (PositiveInfinity, PositiveInfinity). 
  end
  Sinh = function (value)
    -- Use sinh(z) = -i sin(iz) to compute via sin(z).
    local sin = Sin(class(- value.m_imaginary, value.m_real))
    return class(sin.m_imaginary, - sin.m_real)
  end
  Asin = function (value)
    local b, bPrime, v
    b, bPrime, v = Asin_Internal(math.Abs(getReal(value)), math.Abs(getImaginary(value)))

    local u
    if bPrime < 0.0 then
      u = math.Asin(b)
    else
      u = math.Atan(bPrime)
    end

    if getReal(value) < 0.0 then
      u = - u
    end
    if getImaginary(value) < 0.0 then
      v = - v
    end

    return class(u, v)
  end
  Cos = function (value)
    local p = math.Exp(value.m_imaginary)
    local q = 1.0 / p
    local sinh = (p - q) * 0.5
    local cosh = (p + q) * 0.5
    return class(math.Cos(value.m_real) * cosh, - math.Sin(value.m_real) * sinh)
  end
  Cosh = function (value)
    -- Use cosh(z) = cos(iz) to compute via cos(z).
    return Cos(class(- value.m_imaginary, value.m_real))
  end
  Acos = function (value)
    local b, bPrime, v
    b, bPrime, v = Asin_Internal(math.Abs(getReal(value)), math.Abs(getImaginary(value)))

    local u
    if bPrime < 0.0 then
      u = math.Acos(b)
    else
      u = math.Atan(1.0 / bPrime)
    end

    if getReal(value) < 0.0 then
      u = 3.14159265358979 --[[Math.PI]] - u
    end
    if getImaginary(value) > 0.0 then
      v = - v
    end

    return class(u, v)
  end
  Tan = function (value)
    -- tan z = sin z / cos z, but to avoid unnecessary repeated trig computations, use
    --   tan z = (sin(2x) + i sinh(2y)) / (cos(2x) + cosh(2y))
    -- (see Abramowitz & Stegun 4.3.57 or derive by hand), and compute trig functions here.

    -- This approach does not work for |y| > ~355, because sinh(2y) and cosh(2y) overflow,
    -- even though their ratio does not. In that case, divide through by cosh to get:
    --   tan z = (sin(2x) / cosh(2y) + i \tanh(2y)) / (1 + cos(2x) / cosh(2y))
    -- which correctly computes the (tiny) real part and the (normal-sized) imaginary part.

    local x2 = 2.0 * value.m_real
    local y2 = 2.0 * value.m_imaginary
    local p = math.Exp(y2)
    local q = 1.0 / p
    local cosh = (p + q) * 0.5
    if math.Abs(value.m_imaginary) <= 4.0 then
      local sinh = (p - q) * 0.5
      local D = math.Cos(x2) + cosh
      return class(math.Sin(x2) / D, sinh / D)
    else
      local D = 1.0 + math.Cos(x2) / cosh
      return class(math.Sin(x2) / cosh / D, math.Tanh(y2) / D)
    end
  end
  Tanh = function (value)
    -- Use tanh(z) = -i tan(iz) to compute via tan(z).
    local tan = Tan(class(- value.m_imaginary, value.m_real))
    return class(tan.m_imaginary, - tan.m_real)
  end
  Atan = function (value)
    local two = class(2.0, 0.0)
    return (ImaginaryOne / two) * (Log(One - (ImaginaryOne * value)) - Log(One + ImaginaryOne * value))
  end
  Asin_Internal = function (x, y, b, bPrime, v)
    -- This method for the inverse complex sine (and cosine) is described in Hull, Fairgrieve,
    -- and Tang, "Implementing the Complex Arcsine and Arccosine Functions Using Exception Handling",
    -- ACM Transactions on Mathematical Software (1997)
    -- (https://www.researchgate.net/profile/Ping_Tang3/publication/220493330_Implementing_the_Complex_Arcsine_and_Arccosine_Functions_Using_Exception_Handling/links/55b244b208ae9289a085245d.pdf)

    -- First, the basics: start with sin(w) = (e^{iw} - e^{-iw}) / (2i) = z. Here z is the input
    -- and w is the output. To solve for w, define t = e^{i w} and multiply through by t to
    -- get the quadratic equation t^2 - 2 i z t - 1 = 0. The solution is t = i z + sqrt(1 - z^2), so
    --   w = arcsin(z) = - i log( i z + sqrt(1 - z^2) )
    -- Decompose z = x + i y, multiply out i z + sqrt(1 - z^2), use log(s) = |s| + i arg(s), and do a
    -- bunch of algebra to get the components of w = arcsin(z) = u + i v
    --   u = arcsin(beta)  v = sign(y) log(alpha + sqrt(alpha^2 - 1))
    -- where
    --   alpha = (rho + sigma) / 2      beta = (rho - sigma) / 2
    --   rho = sqrt((x + 1)^2 + y^2)    sigma = sqrt((x - 1)^2 + y^2)
    -- These formulas appear in DLMF section 4.23. (http://dlmf.nist.gov/4.23), along with the analogous
    --   arccos(w) = arccos(beta) - i sign(y) log(alpha + sqrt(alpha^2 - 1))
    -- So alpha and beta together give us arcsin(w) and arccos(w).

    -- As written, alpha is not susceptible to cancelation errors, but beta is. To avoid cancelation, note
    --   beta = (rho^2 - sigma^2) / (rho + sigma) / 2 = (2 x) / (rho + sigma) = x / alpha
    -- which is not subject to cancelation. Note alpha >= 1 and |beta| <= 1.

    -- For alpha ~ 1, the argument of the log is near unity, so we compute (alpha - 1) instead,
    -- write the argument as 1 + (alpha - 1) + sqrt((alpha - 1)(alpha + 1)), and use the log1p function
    -- to compute the log without loss of accuracy.
    -- For beta ~ 1, arccos does not accurately resolve small angles, so we compute the tangent of the angle
    -- instead.
    -- Hull, Fairgrieve, and Tang derive formulas for (alpha - 1) and beta' = tan(u) that do not suffer
    -- from cancelation in these cases.

    -- For simplicity, we assume all positive inputs and return all positive outputs. The caller should
    -- assign signs appropriate to the desired cut conventions. We return v directly since its magnitude
    -- is the same for both arcsin and arccos. Instead of u, we usually return beta and sometimes beta'.
    -- If beta' is not computed, it is set to -1; if it is computed, it should be used instead of beta
    -- to determine u. Compute u = arcsin(beta) or u = arctan(beta') for arcsin, u = arccos(beta)
    -- or arctan(1/beta') for arccos.

    assert((x >= 0.0) or System.Double.IsNaN(x))
    assert((y >= 0.0) or System.Double.IsNaN(y))

    -- For x or y large enough to overflow alpha^2, we can simplify our formulas and avoid overflow.
    if (x > s_asinOverflowThreshold) or (y > s_asinOverflowThreshold) then
      b = - 1.0
      bPrime = x / y

      local small, big
      if x < y then
        small = x
        big = y
      else
        small = y
        big = x
      end
      local ratio = small / big
      v = s_log2 + math.Log(big) + 0.5 * Log1P(ratio * ratio)
    else
      local r = Hypot((x + 1.0), y)
      local s = Hypot((x - 1.0), y)

      local a = (r + s) * 0.5
      b = x / a

      if b > 0.75 then
        if x <= 1.0 then
          local amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5
          bPrime = x / math.Sqrt((a + x) * amx)
        else
          -- In this case, amx ~ y^2. Since we take the square root of amx, we should
          -- pull y out from under the square root so we don't lose its contribution
          -- when y^2 underflows.
          local t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5
          bPrime = x / y / math.Sqrt((a + x) * t)
        end
      else
        bPrime = - 1.0
      end

      if a < 1.5 then
        if x < 1.0 then
          -- This is another case where our expression is proportional to y^2 and
          -- we take its square root, so again we pull out a factor of y from
          -- under the square root.
          local t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5
          local am1 = y * y * t
          v = Log1P(am1 + y * math.Sqrt(t * (a + 1.0)))
        else
          local am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5
          v = Log1P(am1 + math.Sqrt(am1 * (a + 1.0)))
        end
      else
        -- Because of the test above, we can be sure that a * a will not overflow.
        v = math.Log(a + math.Sqrt((a - 1.0) * (a + 1.0)))
      end
    end
    return b, bPrime, v
  end
  IsFinite = function (value)
    return System.Double.IsFinite(value.m_real) and System.Double.IsFinite(value.m_imaginary)
  end
  IsInfinity = function (value)
    return System.Double.IsInfinity(value.m_real) or System.Double.IsInfinity(value.m_imaginary)
  end
  IsNaN = function (value)
    return not IsInfinity(value) and not IsFinite(value)
  end
  Log = function (value, baseValue)
    if baseValue ~= nil then
      return (Log(value) / Log(ToComplex(baseValue))) 
    end
    return class(math.Log(Abs(value)), math.Atan2(value.m_imaginary, value.m_real))
  end
  Log10 = function (value)
    local tempLog = Log(value)
    return Scale(tempLog, 0.43429448190325 --[[Complex.InverseOfLog10]])
  end
  Exp = function (value)
    local expReal = math.Exp(value.m_real)
    local cosImaginary = expReal * math.Cos(value.m_imaginary)
    local sinImaginary = expReal * math.Sin(value.m_imaginary)
    return class(cosImaginary, sinImaginary)
  end
  Sqrt = function (value)
    local m_real = value.m_real
    local m_imaginary = value.m_imaginary
    if m_imaginary == 0.0 then
      -- Handle the trivial case quickly.
      if m_real < 0.0 then
        return class(0.0, math.Sqrt(- m_real))
      else
        return class(math.Sqrt(m_real), 0.0)
      end
    else
      -- One way to compute Sqrt(z) is just to call Pow(z, 0.5), which coverts to polar coordinates
      -- (sqrt + atan), halves the phase, and reconverts to cartesian coordinates (cos + sin).
      -- Not only is this more expensive than necessary, it also fails to preserve certain expected
      -- symmetries, such as that the square root of a pure negative is a pure imaginary, and that the
      -- square root of a pure imaginary has exactly equal real and imaginary parts. This all goes
      -- back to the fact that Math.PI is not stored with infinite precision, so taking half of Math.PI
      -- does not land us on an argument with cosine exactly equal to zero.

      -- To find a fast and symmetry-respecting formula for complex square root,
      -- note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b,
      -- so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain
      --   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}
      -- There is just one complication: depending on the sign on a, either x or y suffers from
      -- cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply
      -- x^2 y^2 = b^2 / 4, so |x| |y| = |b| / 2. So after computing the one that doesn't suffer
      -- from cancelation, we can compute the other with just a division. This is basically just
      -- the right way to evaluate the quadratic formula without cancelation.

      -- All this reduces our total cost to two sqrts and a few flops, and it respects the desired
      -- symmetries. Much better than atan + cos + sin!

      -- The signs are a matter of choice of branch cut, which is traditionally taken so x > 0 and sign(y) = sign(b).

      -- If the components are too large, Hypot will overflow, even though the subsequent sqrt would
      -- make the result representable. To avoid this, we re-scale (by exact powers of 2 for accuracy)
      -- when we encounter very large components to avoid intermediate infinities.
      local rescale = false
      if (math.Abs(m_real) >= s_sqrtRescaleThreshold) or (math.Abs(m_imaginary) >= s_sqrtRescaleThreshold) then
        if System.Double.IsInfinity(m_imaginary) and not System.Double.IsNaN(m_real) then
          -- We need to handle infinite imaginary parts specially because otherwise
          -- our formulas below produce inf/inf = NaN. The NaN test is necessary
          -- so that we return NaN rather than (+inf,inf) for (NaN,inf).
          return (class(System.Double.PositiveInfinity, m_imaginary))
        else
          m_real = m_real * 0.25
          m_imaginary = m_imaginary * 0.25
          rescale = true
        end
      end

      -- This is the core of the algorithm. Everything else is special case handling.
      local x, y
      if m_real >= 0.0 then
        x = math.Sqrt((Hypot(m_real, m_imaginary) + m_real) * 0.5)
        y = m_imaginary / (2.0 * x)
      else
        y = math.Sqrt((Hypot(m_real, m_imaginary) - m_real) * 0.5)
        if m_imaginary < 0.0 then
          y = - y
        end
        x = m_imaginary / (2.0 * y)
      end

      if rescale then
        x = x * 2.0
        y = y * 2.0
      end

      return class(x, y)
    end
  end
  Pow = function (value, power)
    if power == Zero then
      return One
    end

    if value == Zero then
      return Zero
    end

    local valueReal = value.m_real
    local valueImaginary = value.m_imaginary
    local powerReal = power.m_real
    local powerImaginary = power.m_imaginary

    local rho = Abs(value)
    local theta = math.Atan2(valueImaginary, valueReal)
    local newRho = powerReal * theta + powerImaginary * math.Log(rho)

    local t = math.Pow(rho, powerReal) * math.Pow(2.71828182845905 --[[Math.E]], - powerImaginary * theta)

    return class(t * math.Cos(newRho), t * math.Sin(newRho))
  end
  Pow1 = function (value, power)
    return Pow(value, class(power, 0))
  end
  Scale = function (value, factor)
    local realResult = factor * value.m_real
    local imaginaryResuilt = factor * value.m_imaginary
    return class(realResult, imaginaryResuilt)
  end
  ToComplex = function (value)
    return class(value, 0.0)
  end
  class = {
    base = function (out, T)
      return {
        System.IEquatable_1(T),
        System.IFormattable
      }
    end,
    m_real = 0,
    m_imaginary = 0,
    getReal = getReal,
    getImaginary = getImaginary,
    getMagnitude = getMagnitude,
    getPhase = getPhase,
    FromPolarCoordinates = FromPolarCoordinates,
    Negate = Negate,
    Add = Add,
    Subtract = Subtract,
    Multiply = Multiply,
    Divide = Divide,
    Abs = Abs,
    Conjugate = Conjugate,
    Reciprocal = Reciprocal,
    EqualsObj = EqualsObj,
    Equals = Equals,
    GetHashCode = GetHashCode,
    ToString = ToString,
    Sin = Sin,
    Sinh = Sinh,
    Asin = Asin,
    Cos = Cos,
    Cosh = Cosh,
    Acos = Acos,
    Tan = Tan,
    Tanh = Tanh,
    Atan = Atan,
    IsFinite = IsFinite,
    IsInfinity = IsInfinity,
    IsNaN = IsNaN,
    Log = Log,
    Log10 = Log10,
    Exp = Exp,
    Sqrt = Sqrt,
    Pow = Pow,
    Pow1 = Pow1,
    ToComplex = ToComplex,
    static = static,
    __ctor__ = __ctor__,
    __add = Add,
    __sub = Subtract,
    __mul = Multiply,
    __div = Divide,
    __unm = Negate,
    __eq = op_Equality
  }
  return class
end)())
