<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DefoldSharp</name>
    </assembly>
    <members>
        <member name="T:attributes.DefoldPropertyProxyGenAttribute">
            <summary>
                Flags a class as a property proxy, and that properties need to be generated on scripts
                that use this class as a proxy.
            </summary>
        </member>
        <member name="T:attributes.GenScriptAttribute">
            <summary>
                Flags a class as needing to be generated to .script file.  This is almost always done
                by deriving from the GameObjectScript class.
                @CSharpLua.Ignore
            </summary>
        </member>
        <member name="T:Buffer">
            <summary>
            Buffer API documentation
            
            </summary>
        </member>
        <member name="M:Buffer.create(System.Double,lua.LuaTableBase)">
            <summary>
            Create a new data buffer containing a specified set of streams. A data buffer
            can contain one or more streams with typed data. This is useful for managing
            compound data, for instance a vertex buffer could contain separate streams for
            vertex position, color, normal etc.
            
            @CSharpLua.Template = "buffer.create({0}, {1})"
            </summary>
        </member>
        <member name="M:Buffer.get_stream(types.DataBuffer,types.Hash)">
            <summary>
            Get a specified stream from a buffer.
            
            @CSharpLua.Template = "buffer.get_stream({0}, {1})"
            </summary>
        </member>
        <member name="M:Buffer.get_stream(types.DataBuffer,System.String)">
            <summary>
            Get a specified stream from a buffer.
            
            @CSharpLua.Template = "buffer.get_stream({0}, {1})"
            </summary>
        </member>
        <member name="M:Buffer.copy_stream(types.BufferStream,System.Double,types.BufferStream,System.Double,System.Double)">
            <summary>
            Copy a specified amount of data from one stream to another.
            <span class="icon-attention"></span> The value type and size must match between source and destination streams.
            The source and destination streams can be the same.
            
            @CSharpLua.Template = "buffer.copy_stream({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Buffer.copy_buffer(types.DataBuffer,System.Double,types.DataBuffer,System.Double,System.Double)">
            <summary>
            Copy all data streams from one buffer to another, element wise.
            <span class="icon-attention"></span> Each of the source streams must have a matching stream in the
            destination buffer. The streams must match in both type and size.
            The source and destination buffer can be the same.
            
            @CSharpLua.Template = "buffer.copy_buffer({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Buffer.get_bytes(types.DataBuffer,types.Hash)">
            <summary>
            Get a copy of all the bytes from a specified stream as a Lua string.
            
            @CSharpLua.Template = "buffer.get_bytes({0}, {1})"
            </summary>
        </member>
        <member name="T:Builtins">
            <summary>
            Built-ins API documentation
            
            </summary>
        </member>
        <member name="M:Builtins.pprint(types.LuaType)">
            <summary>
            Pretty printing of Lua values. This function prints Lua values
            in a manner similar to +print()+, but will also recurse into tables
            and pretty print them. There is a limit to how deep the function
            will recurse.
            
            @CSharpLua.Template = "builtins.pprint({0})"
            </summary>
        </member>
        <member name="M:Builtins.hash(System.String)">
            <summary>
            All ids in the engine are represented as hashes, so a string needs to be hashed
            before it can be compared with an id.
            
            @CSharpLua.Template = "builtins.hash({0})"
            </summary>
        </member>
        <member name="M:Builtins.hash_to_hex(types.Hash)">
            <summary>
            Returns a hexadecimal representation of a hash value.
            The returned string is always padded with leading zeros.
            
            @CSharpLua.Template = "builtins.hash_to_hex({0})"
            </summary>
        </member>
        <member name="T:Camera">
            <summary>
            Camera API documentation
            
            </summary>
        </member>
        <member name="T:Camera.set_camera_message">
            <summary>
            </summary>
        </member>
        <member name="T:Camera.acquire_camera_focus_message">
            <summary>
            </summary>
        </member>
        <member name="T:Camera.release_camera_focus_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionFactory">
            <summary>
            Collection factory API documentation
            
            </summary>
        </member>
        <member name="M:CollectionFactory.get_status">
            <summary>
            This returns status of the collection factory.
            Calling this function when the factory is not marked as dynamic loading always returns COMP_COLLECTION_FACTORY_STATUS_LOADED.
            
            @CSharpLua.Template = "collectionfactory.get_status()"
            </summary>
        </member>
        <member name="M:CollectionFactory.get_status(System.String)">
            <summary>
            This returns status of the collection factory.
            Calling this function when the factory is not marked as dynamic loading always returns COMP_COLLECTION_FACTORY_STATUS_LOADED.
            
            @CSharpLua.Template = "collectionfactory.get_status({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.get_status(types.Hash)">
            <summary>
            This returns status of the collection factory.
            Calling this function when the factory is not marked as dynamic loading always returns COMP_COLLECTION_FACTORY_STATUS_LOADED.
            
            @CSharpLua.Template = "collectionfactory.get_status({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.get_status(types.Url)">
            <summary>
            This returns status of the collection factory.
            Calling this function when the factory is not marked as dynamic loading always returns COMP_COLLECTION_FACTORY_STATUS_LOADED.
            
            @CSharpLua.Template = "collectionfactory.get_status({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.unload">
            <summary>
            This decreases the reference count for each resource loaded with collectionfactory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.unload()"
            </summary>
        </member>
        <member name="M:CollectionFactory.unload(System.String)">
            <summary>
            This decreases the reference count for each resource loaded with collectionfactory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.unload({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.unload(types.Hash)">
            <summary>
            This decreases the reference count for each resource loaded with collectionfactory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.unload({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.unload(types.Url)">
            <summary>
            This decreases the reference count for each resource loaded with collectionfactory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.unload({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load()"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(System.String)">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(System.String,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(types.Hash)">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(types.Hash,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(types.Url)">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.load(types.Url,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources loaded are referenced by the collection factory component until the existing (parent) collection is destroyed or collectionfactory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "collectionfactory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(System.String)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(System.String,types.vector3)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(System.String,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(System.String,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(System.String,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Hash)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Hash,types.vector3)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Hash,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Hash,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Hash,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Url)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Url,types.vector3)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Url,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Url,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:CollectionFactory.create(types.Url,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies the collectionfactory component that should do the spawning.
            Spawning is instant, but spawned game objects get their first update calls the following frame. The supplied parameters for position, rotation and scale
            will be applied to the whole collection when spawned.
            Script properties in the created game objects can be overridden through
            a properties-parameter table. The table should contain game object ids
            (hash) as keys and property tables as values to be used when initiating each
            spawned game object.
            See go.property for more information on script properties.
            The function returns a table that contains a key for each game object
            id (hash), as addressed if the collection file was top level, and the
            corresponding spawned instance id (hash) as value with a unique path
            prefix added to each instance.
            <span class="icon-attention"></span> Calling <a href="/ref/collectionfactory#collectionfactory.create">collectionfactory.create</a> create on a collection factory that is marked as dynamic without having loaded resources
            using <a href="/ref/collectionfactory#collectionfactory.load">collectionfactory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "collectionfactory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="T:CollectionProxy">
            <summary>
            Collection proxy API documentation
            
            </summary>
        </member>
        <member name="T:CollectionProxy.set_time_step_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.load_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.async_load_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.proxy_loaded_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.init_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.enable_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.disable_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.final_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.unload_message">
            <summary>
            </summary>
        </member>
        <member name="T:CollectionProxy.proxy_unloaded_message">
            <summary>
            </summary>
        </member>
        <member name="M:CollectionProxy.get_resources(types.Url)">
            <summary>
            return an indexed table of resources for a collection proxy. Each
            entry is a hexadecimal string that represents the data of the specific
            resource. This representation corresponds with the filename for each
            individual resource that is exported when you bundle an application with
            LiveUpdate functionality.
            
            @CSharpLua.Template = "collectionproxy.get_resources({0})"
            </summary>
        </member>
        <member name="M:CollectionProxy.missing_resources(types.Url)">
            <summary>
            return an array of missing resources for a collection proxy. Each
            entry is a hexadecimal string that represents the data of the specific
            resource. This representation corresponds with the filename for each
            individual resource that is exported when you bundle an application with
            LiveUpdate functionality. It should be considered good practise to always
            check whether or not there are any missing resources in a collection proxy
            before attempting to load the collection proxy.
            
            @CSharpLua.Template = "collectionproxy.missing_resources({0})"
            </summary>
        </member>
        <member name="M:CollectionProxy.Load">
            <summary>
            Posts a load message to the collection-proxy-component to start the loading of the referenced collection. When the loading has completed, the message proxy_loaded will be sent back to the script. A loaded collection must be initialized (message init) and enabled (message enable) in order to be simulated and drawn.
            </summary>
        </member>
        <member name="M:CollectionProxy.LoadAsync">
            <summary>
            Posts a async_load message to a collection-proxy-component to start background loading of the referenced collection. When the loading has completed, the message proxy_loaded will be sent back to the script. A loaded collection must be initialized (message init) and enabled (message enable) in order to be simulated and drawn.
            </summary>
        </member>
        <member name="M:CollectionProxy.Init">
            <summary>
            Post this message to a collection-proxy-component to initialize the game objects and components in the referenced collection. Sending enable to an uninitialized collection proxy automatically initializes it. The init message simply provides a higher level of control.
            </summary>
        </member>
        <member name="M:CollectionProxy.Enable">
            <summary>
            Post this message to a collection-proxy-component to enable the referenced collection, which in turn enables the contained game objects and components. If the referenced collection was not initialized prior to this call, it will automatically be initialized.
            </summary>
        </member>
        <member name="M:CollectionProxy.Disable">
            <summary>
            Post this message to a collection-proxy-component to disable the referenced collection, which in turn disables the contained game objects and components.
            </summary>
        </member>
        <member name="M:CollectionProxy.Final">
            <summary>
            Post this message to a collection-proxy-component to finalize the referenced collection, which in turn finalizes the contained game objects and components.
            </summary>
        </member>
        <member name="M:CollectionProxy.Unload">
            <summary>
            Post this message to a collection-proxy-component to start the unloading of the referenced collection. When the unloading has completed, the message proxy_unloaded will be sent back to the script.
            </summary>
        </member>
        <member name="M:CollectionProxy.SetTimeStep(System.Double,types.TimeStepMode)">
            <summary>
            Post this message to a collection-proxy-component to modify the time-step used when updating the collection controlled by the proxy. The time-step is modified by a scaling factor and can be incremented either continuously or in discrete steps. The continuous mode can be used for slow-motion or fast-forward effects. The discrete mode is only useful when scaling the time-step to pass slower than real time (factor is below 1). The time-step will then be set to 0 for as many frames as the scaling demands and then take on the full real-time-step for one frame, to simulate pulses. E.g. if factor is set to 0.1 the time-step would be 0 for 9 frames, then be 1/60 for one frame, 0 for 9 frames, and so on. The result in practice is that the game looks like it's updated at a much lower frequency than 60 Hz, which can be useful for debugging when each frame needs to be inspected.
            </summary>
            <param name="factor"></param>
            <param name="mode"></param>
        </member>
        <member name="T:Crash">
            <summary>
            Crash API documentation
            
            </summary>
        </member>
        <member name="M:Crash.write_dump">
            <summary>
            Performs the same steps as if a crash had just occured but
            allows the program to continue.
            The generated dump can be read by crash.load_previous
            
            @CSharpLua.Template = "crash.write_dump()"
            </summary>
        </member>
        <member name="M:Crash.set_file_path(System.String)">
            <summary>
            Crashes occuring before the path is set will be stored to a default engine location.
            
            @CSharpLua.Template = "crash.set_file_path({0})"
            </summary>
        </member>
        <member name="M:Crash.load_previous">
            <summary>
            The crash dump will be removed from disk upon a successful
            load, so loading is one-shot.
            
            @CSharpLua.Template = "crash.load_previous()"
            </summary>
        </member>
        <member name="M:Crash.release(System.Double)">
            <summary>
            releases a previously loaded crash dump
            
            @CSharpLua.Template = "crash.release({0})"
            </summary>
        </member>
        <member name="M:Crash.set_user_field(System.Double,System.String)">
            <summary>
            Store a user value that will get written to a crash dump when
            a crash occurs. This can be user id:s, breadcrumb data etc.
            There are 32 slots indexed from 0. Each slot stores at most 255 characters.
            
            @CSharpLua.Template = "crash.set_user_field({0}, {1})"
            </summary>
        </member>
        <member name="M:Crash.get_modules(System.Double)">
            <summary>
            The function returns a table containing entries with sub-tables that
            have fields 'name' and 'address' set for all loaded modules.
            
            @CSharpLua.Template = "crash.get_modules({0})"
            </summary>
        </member>
        <member name="M:Crash.get_user_field(System.Double,System.Double)">
            <summary>
            reads user field from a loaded crash dump
            
            @CSharpLua.Template = "crash.get_user_field({0}, {1})"
            </summary>
        </member>
        <member name="M:Crash.get_sys_field(System.Double,System.Double)">
            <summary>
            reads a system field from a loaded crash dump
            
            @CSharpLua.Template = "crash.get_sys_field({0}, {1})"
            </summary>
        </member>
        <member name="M:Crash.get_signum(System.Double)">
            <summary>
            read signal number from a crash report
            
            @CSharpLua.Template = "crash.get_signum({0})"
            </summary>
        </member>
        <member name="M:Crash.get_backtrace(System.Double)">
            <summary>
            A table is returned containing the addresses of the call stack.
            
            @CSharpLua.Template = "crash.get_backtrace({0})"
            </summary>
        </member>
        <member name="M:Crash.get_extra_data(System.Double)">
            <summary>
            The format of read text blob is platform specific
            and not guaranteed
            but can be useful for manual inspection.
            
            @CSharpLua.Template = "crash.get_extra_data({0})"
            </summary>
        </member>
        <member name="T:Defold">
            <summary>
                @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:Defold.hash(System.String)">
            <summary>
                @CSharpLua.Template = "hash({0})"
            </summary>
        </member>
        <member name="M:Defold.hash_to_hex(types.Hash)">
            <summary>
                @CSharpLua.Template = "hash_to_hex({0})"
            </summary>
        </member>
        <member name="M:Defold.pprint(System.Object)">
            <summary>
                @CSharpLua.Template = "pprint({0})"
            </summary>
        </member>
        <member name="T:Facebook">
            <summary>
            Facebook API documentation
            
            </summary>
        </member>
        <member name="T:Factory">
            <summary>
            Factory API documentation
            
            </summary>
        </member>
        <member name="M:Factory.get_status">
            <summary>
            This returns status of the factory.
            Calling this function when the factory is not marked as dynamic loading always returns
            factory.STATUS_LOADED.
            
            @CSharpLua.Template = "factory.get_status()"
            </summary>
        </member>
        <member name="M:Factory.get_status(System.String)">
            <summary>
            This returns status of the factory.
            Calling this function when the factory is not marked as dynamic loading always returns
            factory.STATUS_LOADED.
            
            @CSharpLua.Template = "factory.get_status({0})"
            </summary>
        </member>
        <member name="M:Factory.get_status(types.Hash)">
            <summary>
            This returns status of the factory.
            Calling this function when the factory is not marked as dynamic loading always returns
            factory.STATUS_LOADED.
            
            @CSharpLua.Template = "factory.get_status({0})"
            </summary>
        </member>
        <member name="M:Factory.get_status(types.Url)">
            <summary>
            This returns status of the factory.
            Calling this function when the factory is not marked as dynamic loading always returns
            factory.STATUS_LOADED.
            
            @CSharpLua.Template = "factory.get_status({0})"
            </summary>
        </member>
        <member name="M:Factory.unload">
            <summary>
            This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.unload()"
            </summary>
        </member>
        <member name="M:Factory.unload(System.String)">
            <summary>
            This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.unload({0})"
            </summary>
        </member>
        <member name="M:Factory.unload(types.Hash)">
            <summary>
            This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.unload({0})"
            </summary>
        </member>
        <member name="M:Factory.unload(types.Url)">
            <summary>
            This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.unload({0})"
            </summary>
        </member>
        <member name="M:Factory.load">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load()"
            </summary>
        </member>
        <member name="M:Factory.load(System.String)">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0})"
            </summary>
        </member>
        <member name="M:Factory.load(System.String,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.load(types.Hash)">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0})"
            </summary>
        </member>
        <member name="M:Factory.load(types.Hash,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.load(types.Url)">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0})"
            </summary>
        </member>
        <member name="M:Factory.load(types.Url,System.Action{System.Object,types.Url,System.Boolean})">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            
            @CSharpLua.Template = "factory.load({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Factory.create(System.String,types.vector3,types.Quaternion,lua.LuaTableBase,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Hash,types.vector3,types.Quaternion,lua.LuaTableBase,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url,types.vector3,types.Quaternion)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url,types.vector3,types.Quaternion,lua.LuaTableBase)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url,types.vector3,types.Quaternion,lua.LuaTableBase,System.Double)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Factory.create(types.Url,types.vector3,types.Quaternion,lua.LuaTableBase,types.vector3)">
            <summary>
            The URL identifies which factory should create the game object.
            If the game object is created inside of the frame (e.g. from an update callback), the game object will be created instantly, but none of its component will be updated in the same frame.
            Properties defined in scripts in the created game object can be overridden through the properties-parameter below.
            See go.property for more information on script properties.
            <span class="icon-attention"></span> Calling <a href="/ref/factory#factory.create">factory.create</a> on a factory that is marked as dynamic without having loaded resources
            using <a href="/ref/factory#factory.load">factory.load</a> will synchronously load and create resources which may affect application performance.
            
            @CSharpLua.Template = "factory.create({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="P:Factory.Status">
            <summary>
            Calling this function when the factory is not marked as dynamic loading always returns
            factory.STATUS_LOADED.
            </summary>
        </member>
        <member name="M:Factory.Unload">
            <summary>
            This decreases the reference count for each resource loaded with factory.load. If reference is zero, the resource is destroyed.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            </summary>
        </member>
        <member name="M:Factory.Load">
            <summary>
            Resources are referenced by the factory component until the existing (parent) collection is destroyed or factory.unload is called.
            Calling this function when the factory is not marked as dynamic loading does nothing.
            </summary>
        </member>
        <member name="T:Go">
            <summary>
            Game object API documentation
            
            </summary>
        </member>
        <member name="T:Go.acquire_input_focus_message">
            <summary>
            </summary>
        </member>
        <member name="T:Go.release_input_focus_message">
            <summary>
            </summary>
        </member>
        <member name="T:Go.set_parent_message">
            <summary>
            </summary>
        </member>
        <member name="T:Go.enable_message">
            <summary>
            </summary>
        </member>
        <member name="T:Go.disable_message">
            <summary>
            </summary>
        </member>
        <member name="M:Go.get(System.String,System.String)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(System.String,System.String,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get(System.String,types.Hash)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(System.String,types.Hash,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get(types.Hash,System.String)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(types.Hash,System.String,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get(types.Hash,types.Hash)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(types.Hash,types.Hash,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get(types.Url,System.String)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(types.Url,System.String,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get(types.Url,types.Hash)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.get(types.Url,types.Hash,lua.LuaTableBase)">
            <summary>
            gets a named property of the specified game object or component
            
            @CSharpLua.Template = "go.get({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(System.String,System.String,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(System.String,System.String,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.set(System.String,types.Hash,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(System.String,types.Hash,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.set(types.Hash,System.String,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(types.Hash,System.String,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.set(types.Hash,types.Hash,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(types.Hash,types.Hash,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.set(types.Url,System.String,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(types.Url,System.String,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.set(types.Url,types.Hash,types.LuaType)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set(types.Url,types.Hash,types.LuaType,lua.LuaTableBase)">
            <summary>
            sets a named property of the specified game object or component, or a material constant
            
            @CSharpLua.Template = "go.set({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Go.get_position">
            <summary>
            The position is relative the parent (if any). Use <a href="/ref/go#go.get_world_position">go.get_world_position</a> to retrieve the global world position.
            
            @CSharpLua.Template = "go.get_position()"
            </summary>
        </member>
        <member name="M:Go.get_position(System.String)">
            <summary>
            The position is relative the parent (if any). Use <a href="/ref/go#go.get_world_position">go.get_world_position</a> to retrieve the global world position.
            
            @CSharpLua.Template = "go.get_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_position(types.Hash)">
            <summary>
            The position is relative the parent (if any). Use <a href="/ref/go#go.get_world_position">go.get_world_position</a> to retrieve the global world position.
            
            @CSharpLua.Template = "go.get_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_position(types.Url)">
            <summary>
            The position is relative the parent (if any). Use <a href="/ref/go#go.get_world_position">go.get_world_position</a> to retrieve the global world position.
            
            @CSharpLua.Template = "go.get_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_rotation">
            <summary>
            The rotation is relative to the parent (if any). Use <a href="/ref/go#go.get_world_rotation">go.get_world_rotation</a> to retrieve the global world rotation.
            
            @CSharpLua.Template = "go.get_rotation()"
            </summary>
        </member>
        <member name="M:Go.get_rotation(System.String)">
            <summary>
            The rotation is relative to the parent (if any). Use <a href="/ref/go#go.get_world_rotation">go.get_world_rotation</a> to retrieve the global world rotation.
            
            @CSharpLua.Template = "go.get_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_rotation(types.Hash)">
            <summary>
            The rotation is relative to the parent (if any). Use <a href="/ref/go#go.get_world_rotation">go.get_world_rotation</a> to retrieve the global world rotation.
            
            @CSharpLua.Template = "go.get_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_rotation(types.Url)">
            <summary>
            The rotation is relative to the parent (if any). Use <a href="/ref/go#go.get_world_rotation">go.get_world_rotation</a> to retrieve the global world rotation.
            
            @CSharpLua.Template = "go.get_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale">
            <summary>
            The scale is relative the parent (if any). Use <a href="/ref/go#go.get_world_scale">go.get_world_scale</a> to retrieve the global world 3D scale factor.
            
            @CSharpLua.Template = "go.get_scale()"
            </summary>
        </member>
        <member name="M:Go.get_scale(System.String)">
            <summary>
            The scale is relative the parent (if any). Use <a href="/ref/go#go.get_world_scale">go.get_world_scale</a> to retrieve the global world 3D scale factor.
            
            @CSharpLua.Template = "go.get_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale(types.Hash)">
            <summary>
            The scale is relative the parent (if any). Use <a href="/ref/go#go.get_world_scale">go.get_world_scale</a> to retrieve the global world 3D scale factor.
            
            @CSharpLua.Template = "go.get_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale(types.Url)">
            <summary>
            The scale is relative the parent (if any). Use <a href="/ref/go#go.get_world_scale">go.get_world_scale</a> to retrieve the global world 3D scale factor.
            
            @CSharpLua.Template = "go.get_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale_uniform">
            <summary>
            The uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.
            
            @CSharpLua.Template = "go.get_scale_uniform()"
            </summary>
        </member>
        <member name="M:Go.get_scale_uniform(System.String)">
            <summary>
            The uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.
            
            @CSharpLua.Template = "go.get_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale_uniform(types.Hash)">
            <summary>
            The uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.
            
            @CSharpLua.Template = "go.get_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.get_scale_uniform(types.Url)">
            <summary>
            The uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.
            
            @CSharpLua.Template = "go.get_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.set_position(types.vector3)">
            <summary>
            The position is relative to the parent (if any). The global world position cannot be manually set.
            
            @CSharpLua.Template = "go.set_position({0})"
            </summary>
        </member>
        <member name="M:Go.set_position(types.vector3,System.String)">
            <summary>
            The position is relative to the parent (if any). The global world position cannot be manually set.
            
            @CSharpLua.Template = "go.set_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_position(types.vector3,types.Hash)">
            <summary>
            The position is relative to the parent (if any). The global world position cannot be manually set.
            
            @CSharpLua.Template = "go.set_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_position(types.vector3,types.Url)">
            <summary>
            The position is relative to the parent (if any). The global world position cannot be manually set.
            
            @CSharpLua.Template = "go.set_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_rotation(types.Quaternion)">
            <summary>
            The rotation is relative to the parent (if any). The global world rotation cannot be manually set.
            
            @CSharpLua.Template = "go.set_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.set_rotation(types.Quaternion,System.String)">
            <summary>
            The rotation is relative to the parent (if any). The global world rotation cannot be manually set.
            
            @CSharpLua.Template = "go.set_rotation({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_rotation(types.Quaternion,types.Hash)">
            <summary>
            The rotation is relative to the parent (if any). The global world rotation cannot be manually set.
            
            @CSharpLua.Template = "go.set_rotation({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_rotation(types.Quaternion,types.Url)">
            <summary>
            The rotation is relative to the parent (if any). The global world rotation cannot be manually set.
            
            @CSharpLua.Template = "go.set_rotation({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(System.Double)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0})"
            </summary>
        </member>
        <member name="M:Go.set_scale(System.Double,System.String)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(System.Double,types.Hash)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(System.Double,types.Url)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(types.vector3)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0})"
            </summary>
        </member>
        <member name="M:Go.set_scale(types.vector3,System.String)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(types.vector3,types.Hash)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_scale(types.vector3,types.Url)">
            <summary>
            The scale factor is relative to the parent (if any). The global world scale factor cannot be manually set.
            <span class="icon-attention"></span> Physics are currently not affected when setting scale from this function.
            
            @CSharpLua.Template = "go.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent()"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,System.String)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,System.String,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,types.Hash)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,types.Hash,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,types.Url)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(System.String,types.Url,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,System.String)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,System.String,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,types.Hash)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,types.Hash,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,types.Url)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Hash,types.Url,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,System.String)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,System.String,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,types.Hash)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,types.Hash,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,types.Url)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.set_parent(types.Url,types.Url,System.Boolean)">
            <summary>
            Sets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent,
            like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world
            space.
            This function will generate a <code>set_parent</code> message. It is not until the message has been processed that the change actually takes effect. This
            typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the
            engine.
            
            @CSharpLua.Template = "go.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Go.get_parent">
            <summary>
            Get the parent for a game object instance.
            
            @CSharpLua.Template = "go.get_parent()"
            </summary>
        </member>
        <member name="M:Go.get_parent(System.String)">
            <summary>
            Get the parent for a game object instance.
            
            @CSharpLua.Template = "go.get_parent({0})"
            </summary>
        </member>
        <member name="M:Go.get_parent(types.Hash)">
            <summary>
            Get the parent for a game object instance.
            
            @CSharpLua.Template = "go.get_parent({0})"
            </summary>
        </member>
        <member name="M:Go.get_parent(types.Url)">
            <summary>
            Get the parent for a game object instance.
            
            @CSharpLua.Template = "go.get_parent({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_position">
            <summary>
            The function will return the world position calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_position">go.get_position</a> to retrieve the position relative to the parent.
            
            @CSharpLua.Template = "go.get_world_position()"
            </summary>
        </member>
        <member name="M:Go.get_world_position(System.String)">
            <summary>
            The function will return the world position calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_position">go.get_position</a> to retrieve the position relative to the parent.
            
            @CSharpLua.Template = "go.get_world_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_position(types.Hash)">
            <summary>
            The function will return the world position calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_position">go.get_position</a> to retrieve the position relative to the parent.
            
            @CSharpLua.Template = "go.get_world_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_position(types.Url)">
            <summary>
            The function will return the world position calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_position">go.get_position</a> to retrieve the position relative to the parent.
            
            @CSharpLua.Template = "go.get_world_position({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_rotation">
            <summary>
            The function will return the world rotation calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_rotation">go.get_rotation</a> to retrieve the rotation relative to the parent.
            
            @CSharpLua.Template = "go.get_world_rotation()"
            </summary>
        </member>
        <member name="M:Go.get_world_rotation(System.String)">
            <summary>
            The function will return the world rotation calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_rotation">go.get_rotation</a> to retrieve the rotation relative to the parent.
            
            @CSharpLua.Template = "go.get_world_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_rotation(types.Hash)">
            <summary>
            The function will return the world rotation calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_rotation">go.get_rotation</a> to retrieve the rotation relative to the parent.
            
            @CSharpLua.Template = "go.get_world_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_rotation(types.Url)">
            <summary>
            The function will return the world rotation calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_rotation">go.get_rotation</a> to retrieve the rotation relative to the parent.
            
            @CSharpLua.Template = "go.get_world_rotation({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale">
            <summary>
            The function will return the world 3D scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale">go.get_scale</a> to retrieve the 3D scale factor relative to the parent.
            This vector is derived by decomposing the transformation matrix and should be used with care.
            For most cases it should be fine to use <a href="/ref/go#go.get_world_scale_uniform">go.get_world_scale_uniform</a> instead.
            
            @CSharpLua.Template = "go.get_world_scale()"
            </summary>
        </member>
        <member name="M:Go.get_world_scale(System.String)">
            <summary>
            The function will return the world 3D scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale">go.get_scale</a> to retrieve the 3D scale factor relative to the parent.
            This vector is derived by decomposing the transformation matrix and should be used with care.
            For most cases it should be fine to use <a href="/ref/go#go.get_world_scale_uniform">go.get_world_scale_uniform</a> instead.
            
            @CSharpLua.Template = "go.get_world_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale(types.Hash)">
            <summary>
            The function will return the world 3D scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale">go.get_scale</a> to retrieve the 3D scale factor relative to the parent.
            This vector is derived by decomposing the transformation matrix and should be used with care.
            For most cases it should be fine to use <a href="/ref/go#go.get_world_scale_uniform">go.get_world_scale_uniform</a> instead.
            
            @CSharpLua.Template = "go.get_world_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale(types.Url)">
            <summary>
            The function will return the world 3D scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale">go.get_scale</a> to retrieve the 3D scale factor relative to the parent.
            This vector is derived by decomposing the transformation matrix and should be used with care.
            For most cases it should be fine to use <a href="/ref/go#go.get_world_scale_uniform">go.get_world_scale_uniform</a> instead.
            
            @CSharpLua.Template = "go.get_world_scale({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale_uniform">
            <summary>
            The function will return the world scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale_uniform">go.get_scale_uniform</a> to retrieve the scale factor relative to the parent.
            
            @CSharpLua.Template = "go.get_world_scale_uniform()"
            </summary>
        </member>
        <member name="M:Go.get_world_scale_uniform(System.String)">
            <summary>
            The function will return the world scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale_uniform">go.get_scale_uniform</a> to retrieve the scale factor relative to the parent.
            
            @CSharpLua.Template = "go.get_world_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale_uniform(types.Hash)">
            <summary>
            The function will return the world scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale_uniform">go.get_scale_uniform</a> to retrieve the scale factor relative to the parent.
            
            @CSharpLua.Template = "go.get_world_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_scale_uniform(types.Url)">
            <summary>
            The function will return the world scale factor calculated at the end of the previous frame.
            Use <a href="/ref/go#go.get_scale_uniform">go.get_scale_uniform</a> to retrieve the scale factor relative to the parent.
            
            @CSharpLua.Template = "go.get_world_scale_uniform({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_transform">
            <summary>
            The function will return the world transform matrix calculated at the end of the previous frame.
            
            @CSharpLua.Template = "go.get_world_transform()"
            </summary>
        </member>
        <member name="M:Go.get_world_transform(System.String)">
            <summary>
            The function will return the world transform matrix calculated at the end of the previous frame.
            
            @CSharpLua.Template = "go.get_world_transform({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_transform(types.Hash)">
            <summary>
            The function will return the world transform matrix calculated at the end of the previous frame.
            
            @CSharpLua.Template = "go.get_world_transform({0})"
            </summary>
        </member>
        <member name="M:Go.get_world_transform(types.Url)">
            <summary>
            The function will return the world transform matrix calculated at the end of the previous frame.
            
            @CSharpLua.Template = "go.get_world_transform({0})"
            </summary>
        </member>
        <member name="M:Go.get_id">
            <summary>
            Returns or constructs an instance identifier. The instance id is a hash
            of the absolute path to the instance.
            <ul>
            <li>If <code>path</code> is specified, it can either be absolute or relative to the instance of the calling script.</li>
            <li>If <code>path</code> is not specified, the id of the game object instance the script is attached to will be returned.</li>
            </ul>
            
            @CSharpLua.Template = "go.get_id()"
            </summary>
        </member>
        <member name="M:Go.get_id(System.String)">
            <summary>
            Returns or constructs an instance identifier. The instance id is a hash
            of the absolute path to the instance.
            <ul>
            <li>If <code>path</code> is specified, it can either be absolute or relative to the instance of the calling script.</li>
            <li>If <code>path</code> is not specified, the id of the game object instance the script is attached to will be returned.</li>
            </ul>
            
            @CSharpLua.Template = "go.get_id({0})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(System.String,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Hash,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,System.String,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double)">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Go.animate(types.Url,types.Hash,types.GoPlaybackMode,types.Quaternion,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Url,types.Hash})">
            <summary>
            This is only supported for numerical properties. If the node property is already being
            animated, that animation will be canceled and replaced by the new one.
            If a <code>complete_function</code> (lua function) is specified, that function will be called when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced together. See the examples for more information.
            <span class="icon-attention"></span> If you call <code>go.animate()</code> from a game object's <code>final()</code> function,
            any passed <code>complete_function</code> will be ignored and never called upon animation completion.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how
            them.
            
            @CSharpLua.Template = "go.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(System.String)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(System.String,System.String)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(System.String,types.Hash)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Hash)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Hash,System.String)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Hash,types.Hash)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Url)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Url,System.String)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.cancel_animations(types.Url,types.Hash)">
            <summary>
            By calling this function, all or specified stored property animations of the game object or component will be canceled.
            See the <a href="/manuals/properties">properties guide</a> for which properties can be animated and the <a href="/manuals/animation">animation guide</a> for how to animate them.
            
            @CSharpLua.Template = "go.cancel_animations({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.delete">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete()"
            </summary>
        </member>
        <member name="M:Go.delete(System.String)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0})"
            </summary>
        </member>
        <member name="M:Go.delete(System.String,System.Boolean)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.delete(types.Hash)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0})"
            </summary>
        </member>
        <member name="M:Go.delete(types.Hash,System.Boolean)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.delete(types.Url)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0})"
            </summary>
        </member>
        <member name="M:Go.delete(types.Url,System.Boolean)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.delete(lua.LuaTableBase)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0})"
            </summary>
        </member>
        <member name="M:Go.delete(lua.LuaTableBase,System.Boolean)">
            <summary>
            Delete one or more game objects identified by id. Deletion is asynchronous meaning that
            the game object(s) are scheduled for deletion which will happen at the end of the current
            frame. Note that game objects scheduled for deletion will be counted against
            <code>max_instances</code> in "game.project" until they are actually removed.
            <span class="icon-attention"></span> Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using <code>particlefx.stop()</code>.
            <span class="icon-attention"></span> Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using <code>sound.stop()</code>.
            
            @CSharpLua.Template = "go.delete({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,System.Double)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,types.Hash)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,types.Url)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,types.vector3)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,types.vector4)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="M:Go.property(System.String,types.Quaternion)">
            <summary>
            This function defines a property which can then be used in the script through the self-reference.
            The properties defined this way are automatically exposed in the editor in game objects and collections which use the script.
            Note that you can only use this function outside any callback-functions like init and update.
            
            @CSharpLua.Template = "go.property({0}, {1})"
            </summary>
        </member>
        <member name="T:Gui">
            <summary>
            GUI API documentation
            
            </summary>
        </member>
        <member name="T:Gui.layout_changed_message">
            <summary>
            </summary>
        </member>
        <member name="M:Gui.get_node(System.String)">
            <summary>
            Retrieves the node with the specified id.
            
            @CSharpLua.Template = "gui.get_node({0})"
            </summary>
        </member>
        <member name="M:Gui.get_node(types.Hash)">
            <summary>
            Retrieves the node with the specified id.
            
            @CSharpLua.Template = "gui.get_node({0})"
            </summary>
        </member>
        <member name="M:Gui.get_id(types.Node)">
            <summary>
            Retrieves the id of the specified node.
            
            @CSharpLua.Template = "gui.get_id({0})"
            </summary>
        </member>
        <member name="M:Gui.set_id(types.Node,System.String)">
            <summary>
            Set the id of the specicied node to a new value.
            Nodes created with the gui.new_*_node() functions get
            an empty id. This function allows you to give dynamically
            created nodes an id.
            <span class="icon-attention"></span> No checking is done on the uniqueness of supplied ids.
            It is up to you to make sure you use unique ids.
            
            @CSharpLua.Template = "gui.set_id({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_id(types.Node,types.Hash)">
            <summary>
            Set the id of the specicied node to a new value.
            Nodes created with the gui.new_*_node() functions get
            an empty id. This function allows you to give dynamically
            created nodes an id.
            <span class="icon-attention"></span> No checking is done on the uniqueness of supplied ids.
            It is up to you to make sure you use unique ids.
            
            @CSharpLua.Template = "gui.set_id({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_index(types.Node)">
            <summary>
            Retrieve the index of the specified node among its siblings.
            The index defines the order in which a node appear in a GUI scene.
            Higher index means the node is drawn on top of lower indexed nodes.
            
            @CSharpLua.Template = "gui.get_index({0})"
            </summary>
        </member>
        <member name="M:Gui.delete_node(types.Node)">
            <summary>
            Deletes the specified node. Any child nodes of the specified node will be
            recursively deleted.
            
            @CSharpLua.Template = "gui.delete_node({0})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,System.Double,types.Easing,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,System.Double,types.Easing,System.Double,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node})">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,System.Double,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node},types.GuiPlaybackMode)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector3,types.Easing,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector3,types.Easing,System.Double,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node})">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector3,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node},types.GuiPlaybackMode)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector4,types.Easing,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector4,types.Easing,System.Double,System.Double)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node})">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Gui.animate(types.Node,System.String,types.vector4,types.Easing,System.Double,System.Double,System.Action{System.Object,types.Node},types.GuiPlaybackMode)">
            <summary>
            This starts an animation of a node property according to the specified parameters.
            If the node property is already being animated, that animation will be canceled and
            replaced by the new one. Note however that several different node properties
            can be animated simultaneously. Use <code>gui.cancel_animation</code> to stop the animation
            before it has completed.
            Composite properties of type vector3, vector4 or quaternion
            also expose their sub-components (x, y, z and w).
            You can address the components individually by suffixing the name with a dot '.'
            and the name of the component.
            For instance, <code>"position.x"</code> (the position x coordinate) or <code>"color.w"</code>
            (the color alpha value).
            If a <code>complete_function</code> (Lua function) is specified, that function will be called
            when the animation has completed.
            By starting a new animation in that function, several animations can be sequenced
            together. See the examples below for more information.
            
            @CSharpLua.Template = "gui.animate({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})"
            </summary>
        </member>
        <member name="M:Gui.cancel_animation(types.Node,System.String)">
            <summary>
            If an animation of the specified node is currently running (started by <code>gui.animate</code>), it will immediately be canceled.
            
            @CSharpLua.Template = "gui.cancel_animation({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_box_node(types.vector3,types.vector3)">
            <summary>
            Dynamically create a new box node.
            
            @CSharpLua.Template = "gui.new_box_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_box_node(types.vector4,types.vector3)">
            <summary>
            Dynamically create a new box node.
            
            @CSharpLua.Template = "gui.new_box_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_text_node(types.vector3,System.String)">
            <summary>
            Dynamically create a new text node.
            
            @CSharpLua.Template = "gui.new_text_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_text_node(types.vector4,System.String)">
            <summary>
            Dynamically create a new text node.
            
            @CSharpLua.Template = "gui.new_text_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_pie_node(types.vector3,types.vector3)">
            <summary>
            Dynamically create a new pie node.
            
            @CSharpLua.Template = "gui.new_pie_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_pie_node(types.vector4,types.vector3)">
            <summary>
            Dynamically create a new pie node.
            
            @CSharpLua.Template = "gui.new_pie_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_text(types.Node)">
            <summary>
            Returns the text value of a text node. This is only useful for text nodes.
            
            @CSharpLua.Template = "gui.get_text({0})"
            </summary>
        </member>
        <member name="M:Gui.set_text(types.Node,System.String)">
            <summary>
            Set the text value of a text node. This is only useful for text nodes.
            
            @CSharpLua.Template = "gui.set_text({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_line_break(types.Node)">
            <summary>
            Returns whether a text node is in line-break mode or not.
            This is only useful for text nodes.
            
            @CSharpLua.Template = "gui.get_line_break({0})"
            </summary>
        </member>
        <member name="M:Gui.set_line_break(types.Node,System.Boolean)">
            <summary>
            Sets the line-break mode on a text node.
            This is only useful for text nodes.
            
            @CSharpLua.Template = "gui.set_line_break({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_blend_mode">
            <summary>
            Returns the blend mode of a node.
            Blend mode defines how the node will be blended with the background.
            
            @CSharpLua.Template = "gui.get_blend_mode()"
            </summary>
        </member>
        <member name="M:Gui.set_blend_mode(types.Node,types.BlendMode)">
            <summary>
            Set the blend mode of a node.
            Blend mode defines how the node will be blended with the background.
            
            @CSharpLua.Template = "gui.set_blend_mode({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_texture(types.Node)">
            <summary>
            Returns the texture of a node.
            This is currently only useful for box or pie nodes.
            The texture must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.get_texture({0})"
            </summary>
        </member>
        <member name="M:Gui.set_texture(types.Node,System.String)">
            <summary>
            Set the texture on a box or pie node. The texture must be mapped to
            the gui scene in the gui editor. The function points out which texture
            the node should render from. If the texture is an atlas, further
            information is needed to select which image/animation in the atlas
            to render. In such cases, use <code>gui.play_flipbook()</code> in
            addition to this function.
            
            @CSharpLua.Template = "gui.set_texture({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_texture(types.Node,types.Hash)">
            <summary>
            Set the texture on a box or pie node. The texture must be mapped to
            the gui scene in the gui editor. The function points out which texture
            the node should render from. If the texture is an atlas, further
            information is needed to select which image/animation in the atlas
            to render. In such cases, use <code>gui.play_flipbook()</code> in
            addition to this function.
            
            @CSharpLua.Template = "gui.set_texture({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_flipbook(types.Node)">
            <summary>
            Get node flipbook animation.
            
            @CSharpLua.Template = "gui.get_flipbook({0})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,System.String)">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,System.String,System.Action{System.Object,types.Node})">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,System.String,System.Action{System.Object,types.Node},lua.LuaTableBase)">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,types.Hash)">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,types.Hash,System.Action{System.Object,types.Node})">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.play_flipbook(types.Node,types.Hash,System.Action{System.Object,types.Node},lua.LuaTableBase)">
            <summary>
            Play flipbook animation on a box or pie node.
            The current node texture must contain the animation.
            Use this function to set one-frame still images on the node.
            
            @CSharpLua.Template = "gui.play_flipbook({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Gui.cancel_flipbook(types.Node)">
            <summary>
            Cancels any running flipbook animation on the specified node.
            
            @CSharpLua.Template = "gui.cancel_flipbook({0})"
            </summary>
        </member>
        <member name="M:Gui.new_texture(System.String,System.Double,System.Double,types.GuiTextureType,System.String,System.Boolean,System.Double@)">
            <summary>
            Dynamically create a new texture.
            
            @CSharpLua.Template = "gui.new_texture({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.new_texture(types.Hash,System.Double,System.Double,types.GuiTextureType,System.String,System.Boolean,System.Double@)">
            <summary>
            Dynamically create a new texture.
            
            @CSharpLua.Template = "gui.new_texture({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.delete_texture(System.String)">
            <summary>
            Delete a dynamically created texture.
            
            @CSharpLua.Template = "gui.delete_texture({0})"
            </summary>
        </member>
        <member name="M:Gui.delete_texture(types.Hash)">
            <summary>
            Delete a dynamically created texture.
            
            @CSharpLua.Template = "gui.delete_texture({0})"
            </summary>
        </member>
        <member name="M:Gui.set_texture_data(System.String,System.Double,System.Double,types.GuiTextureType,System.String,System.Boolean)">
            <summary>
            Set the texture buffer data for a dynamically created texture.
            
            @CSharpLua.Template = "gui.set_texture_data({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.set_texture_data(types.Hash,System.Double,System.Double,types.GuiTextureType,System.String,System.Boolean)">
            <summary>
            Set the texture buffer data for a dynamically created texture.
            
            @CSharpLua.Template = "gui.set_texture_data({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Gui.get_font(types.Node)">
            <summary>
            This is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.get_font({0})"
            </summary>
        </member>
        <member name="M:Gui.get_font_resource(types.Hash)">
            <summary>
            This is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.get_font_resource({0})"
            </summary>
        </member>
        <member name="M:Gui.get_font_resource(System.String)">
            <summary>
            This is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.get_font_resource({0})"
            </summary>
        </member>
        <member name="M:Gui.set_font(types.Node,System.String)">
            <summary>
            This is only useful for text nodes.
            The font must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.set_font({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_font(types.Node,types.Hash)">
            <summary>
            This is only useful for text nodes.
            The font must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.set_font({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_layer(types.Node)">
            <summary>
            The layer must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.get_layer({0})"
            </summary>
        </member>
        <member name="M:Gui.set_layer(types.Node,System.String)">
            <summary>
            The layer must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.set_layer({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_layer(types.Node,types.Hash)">
            <summary>
            The layer must be mapped to the gui scene in the gui editor.
            
            @CSharpLua.Template = "gui.set_layer({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_layout">
            <summary>
            gets the scene current layout
            
            @CSharpLua.Template = "gui.get_layout()"
            </summary>
        </member>
        <member name="M:Gui.get_clipping_mode">
            <summary>
            Clipping mode defines how the node will clip it's children nodes
            
            @CSharpLua.Template = "gui.get_clipping_mode()"
            </summary>
        </member>
        <member name="M:Gui.set_clipping_mode(types.Node,types.ClippingMode)">
            <summary>
            Clipping mode defines how the node will clip it's children nodes
            
            @CSharpLua.Template = "gui.set_clipping_mode({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_clipping_visible(types.Node)">
            <summary>
            If node is set as visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually.
            
            @CSharpLua.Template = "gui.get_clipping_visible({0})"
            </summary>
        </member>
        <member name="M:Gui.set_clipping_visible(types.Node,System.Boolean)">
            <summary>
            If node is set as an visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually.
            
            @CSharpLua.Template = "gui.set_clipping_visible({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_clipping_inverted(types.Node)">
            <summary>
            If node is set as an inverted clipping node, it will clip anything inside as opposed to outside.
            
            @CSharpLua.Template = "gui.get_clipping_inverted({0})"
            </summary>
        </member>
        <member name="M:Gui.set_clipping_inverted(types.Node,System.Boolean)">
            <summary>
            If node is set as an inverted clipping node, it will clip anything inside as opposed to outside.
            
            @CSharpLua.Template = "gui.set_clipping_inverted({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_xanchor">
            <summary>
            The x-anchor specifies how the node is moved when the game is run in a different resolution.
            
            @CSharpLua.Template = "gui.get_xanchor()"
            </summary>
        </member>
        <member name="M:Gui.set_xanchor(types.Node,types.GuiAnchor)">
            <summary>
            The x-anchor specifies how the node is moved when the game is run in a different resolution.
            
            @CSharpLua.Template = "gui.set_xanchor({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_yanchor">
            <summary>
            The y-anchor specifies how the node is moved when the game is run in a different resolution.
            
            @CSharpLua.Template = "gui.get_yanchor()"
            </summary>
        </member>
        <member name="M:Gui.set_yanchor(types.Node,types.GuiAnchor)">
            <summary>
            The y-anchor specifies how the node is moved when the game is run in a different resolution.
            
            @CSharpLua.Template = "gui.set_yanchor({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_pivot(types.GuiPivot@)">
            <summary>
            The pivot specifies how the node is drawn and rotated from its position.
            
            @CSharpLua.Template = "gui.get_pivot()"
            </summary>
        </member>
        <member name="M:Gui.set_pivot(types.Node,types.GuiPivot)">
            <summary>
            The pivot specifies how the node is drawn and rotated from its position.
            
            @CSharpLua.Template = "gui.set_pivot({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_width">
            <summary>
            Returns the scene width.
            
            @CSharpLua.Template = "gui.get_width()"
            </summary>
        </member>
        <member name="M:Gui.get_height">
            <summary>
            Returns the scene height.
            
            @CSharpLua.Template = "gui.get_height()"
            </summary>
        </member>
        <member name="M:Gui.set_slice9(types.Node,types.vector4)">
            <summary>
            Set the slice9 configuration values for the node.
            
            @CSharpLua.Template = "gui.set_slice9({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_slice9(types.Node)">
            <summary>
            Returns the slice9 configuration values for the node.
            
            @CSharpLua.Template = "gui.get_slice9({0})"
            </summary>
        </member>
        <member name="M:Gui.set_perimeter_vertices(types.Node,System.Double)">
            <summary>
            Sets the number of generated vertices around the perimeter of a pie node.
            
            @CSharpLua.Template = "gui.set_perimeter_vertices({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_perimeter_vertices(types.Node)">
            <summary>
            Returns the number of generated vertices around the perimeter
            of a pie node.
            
            @CSharpLua.Template = "gui.get_perimeter_vertices({0})"
            </summary>
        </member>
        <member name="M:Gui.set_fill_angle(types.Node,System.Double)">
            <summary>
            Set the sector angle of a pie node.
            
            @CSharpLua.Template = "gui.set_fill_angle({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_fill_angle(types.Node)">
            <summary>
            Returns the sector angle of a pie node.
            
            @CSharpLua.Template = "gui.get_fill_angle({0})"
            </summary>
        </member>
        <member name="M:Gui.set_inner_radius(types.Node,System.Double)">
            <summary>
            Sets the inner radius of a pie node.
            The radius is defined along the x-axis.
            
            @CSharpLua.Template = "gui.set_inner_radius({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_inner_radius(types.Node)">
            <summary>
            Returns the inner radius of a pie node.
            The radius is defined along the x-axis.
            
            @CSharpLua.Template = "gui.get_inner_radius({0})"
            </summary>
        </member>
        <member name="M:Gui.set_outer_bounds(types.Node,types.PieBounds)">
            <summary>
            Sets the outer bounds mode for a pie node.
            
            @CSharpLua.Template = "gui.set_outer_bounds({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_outer_bounds(types.Node)">
            <summary>
            Returns the outer bounds mode for a pie node.
            
            @CSharpLua.Template = "gui.get_outer_bounds({0})"
            </summary>
        </member>
        <member name="M:Gui.set_leading(types.Node,System.Double)">
            <summary>
            Sets the leading value for a text node. This value is used to
            scale the line spacing of text.
            
            @CSharpLua.Template = "gui.set_leading({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_leading(types.Node)">
            <summary>
            Returns the leading value for a text node.
            
            @CSharpLua.Template = "gui.get_leading({0})"
            </summary>
        </member>
        <member name="M:Gui.set_tracking(types.Node,System.Double)">
            <summary>
            Sets the tracking value of a text node. This value is used to
            adjust the vertical spacing of characters in the text.
            
            @CSharpLua.Template = "gui.set_tracking({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_tracking(types.Node)">
            <summary>
            Returns the tracking value of a text node.
            
            @CSharpLua.Template = "gui.get_tracking({0})"
            </summary>
        </member>
        <member name="M:Gui.pick_node(types.Node,System.Double,System.Double)">
            <summary>
            Tests whether a coordinate is within the bounding box of a
            node.
            
            @CSharpLua.Template = "gui.pick_node({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.is_enabled(types.Node,System.Boolean)">
            <summary>
            Returns <code>true</code> if a node is enabled and <code>false</code> if it's not.
            Disabled nodes are not rendered and animations acting on them are not evaluated.
            
            @CSharpLua.Template = "gui.is_enabled({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_enabled(types.Node,System.Boolean)">
            <summary>
            Sets a node to the disabled or enabled state.
            Disabled nodes are not rendered and animations acting on them are not evaluated.
            
            @CSharpLua.Template = "gui.set_enabled({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_visible(types.Node)">
            <summary>
            Returns <code>true</code> if a node is visible and <code>false</code> if it's not.
            Invisible nodes are not rendered.
            
            @CSharpLua.Template = "gui.get_visible({0})"
            </summary>
        </member>
        <member name="M:Gui.set_visible(types.Node,System.Boolean)">
            <summary>
            Set if a node should be visible or not. Only visible nodes are rendered.
            
            @CSharpLua.Template = "gui.set_visible({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_adjust_mode(types.Node)">
            <summary>
            Returns the adjust mode of a node.
            The adjust mode defines how the node will adjust itself to screen
            resolutions that differs from the one in the project settings.
            
            @CSharpLua.Template = "gui.get_adjust_mode({0})"
            </summary>
        </member>
        <member name="M:Gui.set_adjust_mode(types.Node,types.AdjustMode)">
            <summary>
            Sets the adjust mode on a node.
            The adjust mode defines how the node will adjust itself to screen
            resolutions that differs from the one in the project settings.
            
            @CSharpLua.Template = "gui.set_adjust_mode({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_size_mode(types.Node)">
            <summary>
            Returns the size of a node.
            The size mode defines how the node will adjust itself in size. Automatic
            size mode alters the node size based on the node's content. Automatic size
            mode works for Box nodes and Pie nodes which will both adjust their size
            to match the assigned image. Particle fx and Text nodes will ignore
            any size mode setting.
            
            @CSharpLua.Template = "gui.get_size_mode({0})"
            </summary>
        </member>
        <member name="M:Gui.set_size_mode(types.Node,types.SizeMode)">
            <summary>
            Sets the size mode of a node.
            The size mode defines how the node will adjust itself in size. Automatic
            size mode alters the node size based on the node's content. Automatic size
            mode works for Box nodes and Pie nodes which will both adjust their size
            to match the assigned image. Particle fx and Text nodes will ignore
            any size mode setting.
            
            @CSharpLua.Template = "gui.set_size_mode({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.move_above(types.Node,types.Node)">
            <summary>
            Alters the ordering of the two supplied nodes by moving the first node
            above the second.
            If the second argument is <code>nil</code> the first node is moved to the top.
            
            @CSharpLua.Template = "gui.move_above({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.move_above(types.Node)">
            <summary>
            Alters the ordering of the two supplied nodes by moving the first node
            above the second.
            If the second argument is <code>nil</code> the first node is moved to the top.
            
            @CSharpLua.Template = "gui.move_above({0})"
            </summary>
        </member>
        <member name="M:Gui.move_below(types.Node,types.Node)">
            <summary>
            Alters the ordering of the two supplied nodes by moving the first node
            below the second.
            If the second argument is <code>nil</code> the first node is moved to the bottom.
            
            @CSharpLua.Template = "gui.move_below({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.move_below(types.Node)">
            <summary>
            Alters the ordering of the two supplied nodes by moving the first node
            below the second.
            If the second argument is <code>nil</code> the first node is moved to the bottom.
            
            @CSharpLua.Template = "gui.move_below({0})"
            </summary>
        </member>
        <member name="M:Gui.get_parent(types.Node)">
            <summary>
            Returns the parent node of the specified node.
            If the supplied node does not have a parent, <code>nil</code> is returned.
            
            @CSharpLua.Template = "gui.get_parent({0})"
            </summary>
        </member>
        <member name="M:Gui.set_parent(types.Node,types.Node,System.Boolean)">
            <summary>
            Sets the parent node of the specified node.
            
            @CSharpLua.Template = "gui.set_parent({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.clone(types.Node)">
            <summary>
            Make a clone instance of a node.
            This function does not clone the supplied node's children nodes.
            Use gui.clone_tree for that purpose.
            
            @CSharpLua.Template = "gui.clone({0})"
            </summary>
        </member>
        <member name="M:Gui.clone_tree(types.Node)">
            <summary>
            Make a clone instance of a node and all its children.
            Use gui.clone to clone a node excluding its children.
            
            @CSharpLua.Template = "gui.clone_tree({0})"
            </summary>
        </member>
        <member name="M:Gui.reset_nodes">
            <summary>
            Resets all nodes in the current GUI scene to their initial state.
            The reset only applies to static node loaded from the scene.
            Nodes that are created dynamically from script are not affected.
            
            @CSharpLua.Template = "gui.reset_nodes()"
            </summary>
        </member>
        <member name="M:Gui.set_render_order(System.Double)">
            <summary>
            Set the order number for the current GUI scene.
            The number dictates the sorting of the "gui" render predicate,
            in other words in which order the scene will be rendered in relation
            to other currently rendered GUI scenes.
            The number must be in the range 0 to 15.
            
            @CSharpLua.Template = "gui.set_render_order({0})"
            </summary>
        </member>
        <member name="M:Gui.show_keyboard(types.KeyboardType,System.Boolean)">
            <summary>
            Shows the on-display touch keyboard.
            The specified type of keyboard is displayed if it is available on
            the device.
            This function is only available on iOS and Android. <span class="icon-ios"></span> <span class="icon-android"></span>.
            
            @CSharpLua.Template = "gui.show_keyboard({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.hide_keyboard">
            <summary>
            Hides the on-display touch keyboard on the device.
            
            @CSharpLua.Template = "gui.hide_keyboard()"
            </summary>
        </member>
        <member name="M:Gui.reset_keyboard">
            <summary>
            Resets the input context of keyboard. This will clear marked text.
            
            @CSharpLua.Template = "gui.reset_keyboard()"
            </summary>
        </member>
        <member name="M:Gui.get_position(types.Node)">
            <summary>
            Returns the position of the supplied node.
            
            @CSharpLua.Template = "gui.get_position({0})"
            </summary>
        </member>
        <member name="M:Gui.set_position(types.Node,types.vector3)">
            <summary>
            Sets the position of the supplied node.
            
            @CSharpLua.Template = "gui.set_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_position(types.Node,types.vector4)">
            <summary>
            Sets the position of the supplied node.
            
            @CSharpLua.Template = "gui.set_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_rotation(types.Node)">
            <summary>
            Returns the rotation of the supplied node.
            The rotation is expressed in degree Euler angles.
            
            @CSharpLua.Template = "gui.get_rotation({0})"
            </summary>
        </member>
        <member name="M:Gui.set_rotation(types.Node,types.vector3)">
            <summary>
            Sets the rotation of the supplied node.
            The rotation is expressed in degree Euler angles.
            
            @CSharpLua.Template = "gui.set_rotation({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_rotation(types.Node,types.vector4)">
            <summary>
            Sets the rotation of the supplied node.
            The rotation is expressed in degree Euler angles.
            
            @CSharpLua.Template = "gui.set_rotation({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_scale(types.Node)">
            <summary>
            Returns the scale of the supplied node.
            
            @CSharpLua.Template = "gui.get_scale({0})"
            </summary>
        </member>
        <member name="M:Gui.set_scale(types.Node,types.vector3)">
            <summary>
            Sets the scaling of the supplied node.
            
            @CSharpLua.Template = "gui.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_scale(types.Node,types.vector4)">
            <summary>
            Sets the scaling of the supplied node.
            
            @CSharpLua.Template = "gui.set_scale({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_color(types.Node)">
            <summary>
            Returns the color of the supplied node. The components
            of the returned vector4 contains the color channel values:
            <table>
            <thead>
            <tr>
            <th>Component</th>
            <th>Color value</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td>x</td>
            <td>Red value</td>
            </tr>
            <tr>
            <td>y</td>
            <td>Green value</td>
            </tr>
            <tr>
            <td>z</td>
            <td>Blue value</td>
            </tr>
            <tr>
            <td>w</td>
            <td>Alpha value</td>
            </tr>
            </tbody>
            </table>
            
            @CSharpLua.Template = "gui.get_color({0})"
            </summary>
        </member>
        <member name="M:Gui.set_color(types.Node,types.vector3)">
            <summary>
            Sets the color of the supplied node. The components
            of the supplied vector3 or vector4 should contain the color channel values:
            <table>
            <thead>
            <tr>
            <th>Component</th>
            <th>Color value</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td>x</td>
            <td>Red value</td>
            </tr>
            <tr>
            <td>y</td>
            <td>Green value</td>
            </tr>
            <tr>
            <td>z</td>
            <td>Blue value</td>
            </tr>
            <tr>
            <td>w <span class="type">vector4</span></td>
            <td>Alpha value</td>
            </tr>
            </tbody>
            </table>
            
            @CSharpLua.Template = "gui.set_color({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_color(types.Node,types.vector4)">
            <summary>
            Sets the color of the supplied node. The components
            of the supplied vector3 or vector4 should contain the color channel values:
            <table>
            <thead>
            <tr>
            <th>Component</th>
            <th>Color value</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td>x</td>
            <td>Red value</td>
            </tr>
            <tr>
            <td>y</td>
            <td>Green value</td>
            </tr>
            <tr>
            <td>z</td>
            <td>Blue value</td>
            </tr>
            <tr>
            <td>w <span class="type">vector4</span></td>
            <td>Alpha value</td>
            </tr>
            </tbody>
            </table>
            
            @CSharpLua.Template = "gui.set_color({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_outline(types.Node)">
            <summary>
            Returns the outline color of the supplied node.
            See <a href="/ref/gui#gui.get_color">gui.get_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.get_outline({0})"
            </summary>
        </member>
        <member name="M:Gui.set_outline(types.Node,types.vector3)">
            <summary>
            Sets the outline color of the supplied node.
            See <a href="/ref/gui#gui.set_color">gui.set_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.set_outline({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_outline(types.Node,types.vector4)">
            <summary>
            Sets the outline color of the supplied node.
            See <a href="/ref/gui#gui.set_color">gui.set_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.set_outline({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_shadow(types.Node)">
            <summary>
            Returns the shadow color of the supplied node.
            See <a href="/ref/gui#gui.get_color">gui.get_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.get_shadow({0})"
            </summary>
        </member>
        <member name="M:Gui.set_shadow(types.Node,types.vector3)">
            <summary>
            Sets the shadow color of the supplied node.
            See <a href="/ref/gui#gui.set_color">gui.set_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.set_shadow({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_shadow(types.Node,types.vector4)">
            <summary>
            Sets the shadow color of the supplied node.
            See <a href="/ref/gui#gui.set_color">gui.set_color</a> for info how vectors encode color values.
            
            @CSharpLua.Template = "gui.set_shadow({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_size(types.Node,types.vector3)">
            <summary>
            Sets the size of the supplied node.
            <span class="icon-attention"></span> You can only set size on nodes with size mode set to SIZE_MODE_MANUAL
            
            @CSharpLua.Template = "gui.set_size({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_size(types.Node,types.vector4)">
            <summary>
            Sets the size of the supplied node.
            <span class="icon-attention"></span> You can only set size on nodes with size mode set to SIZE_MODE_MANUAL
            
            @CSharpLua.Template = "gui.set_size({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_size(types.Node)">
            <summary>
            Returns the size of the supplied node.
            
            @CSharpLua.Template = "gui.get_size({0})"
            </summary>
        </member>
        <member name="M:Gui.get_screen_position(types.Node)">
            <summary>
            Returns the screen position of the supplied node. This function returns the
            calculated transformed position of the node, taking into account any parent node
            transforms.
            
            @CSharpLua.Template = "gui.get_screen_position({0})"
            </summary>
        </member>
        <member name="M:Gui.set_screen_position(types.Node,types.vector3)">
            <summary>
            Set the screen position to the supplied node
            
            @CSharpLua.Template = "gui.set_screen_position({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.screen_to_local(types.Node,types.vector3)">
            <summary>
            Convert the screen position to the local position of supplied node
            
            @CSharpLua.Template = "gui.screen_to_local({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_flipbook_cursor(types.Node,System.Double)">
            <summary>
            This is only useful nodes with flipbook animations. The cursor is normalized.
            
            @CSharpLua.Template = "gui.set_flipbook_cursor({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_flipbook_playback_rate(types.Node)">
            <summary>
            This is only useful nodes with flipbook animations. Gets the playback rate of the flipbook animation on a node.
            
            @CSharpLua.Template = "gui.get_flipbook_playback_rate({0})"
            </summary>
        </member>
        <member name="M:Gui.set_flipbook_playback_rate(types.Node,System.Double)">
            <summary>
            This is only useful nodes with flipbook animations. Sets the playback rate of the flipbook animation on a node. Must be positive.
            
            @CSharpLua.Template = "gui.set_flipbook_playback_rate({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_particlefx_node(types.vector3,types.Hash)">
            <summary>
            Dynamically create a particle fx node.
            
            @CSharpLua.Template = "gui.new_particlefx_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_particlefx_node(types.vector3,System.String)">
            <summary>
            Dynamically create a particle fx node.
            
            @CSharpLua.Template = "gui.new_particlefx_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_particlefx_node(types.vector4,types.Hash)">
            <summary>
            Dynamically create a particle fx node.
            
            @CSharpLua.Template = "gui.new_particlefx_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.new_particlefx_node(types.vector4,System.String)">
            <summary>
            Dynamically create a particle fx node.
            
            @CSharpLua.Template = "gui.new_particlefx_node({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.play_particlefx(types.Node)">
            <summary>
            Plays the paricle fx for a gui node
            
            @CSharpLua.Template = "gui.play_particlefx({0})"
            </summary>
        </member>
        <member name="M:Gui.play_particlefx(types.Node,System.Action{System.Object,types.Hash,types.Hash,types.ParticleEmitterState})">
            <summary>
            Plays the paricle fx for a gui node
            
            @CSharpLua.Template = "gui.play_particlefx({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.stop_particlefx(types.Node,lua.LuaTableBase)">
            <summary>
            Stops the particle fx for a gui node
            
            @CSharpLua.Template = "gui.stop_particlefx({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_particlefx(types.Node,types.Hash)">
            <summary>
            Set the paricle fx for a gui node
            
            @CSharpLua.Template = "gui.set_particlefx({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.set_particlefx(types.Node,System.String)">
            <summary>
            Set the paricle fx for a gui node
            
            @CSharpLua.Template = "gui.set_particlefx({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_particlefx(types.Node)">
            <summary>
            Get the paricle fx for a gui node
            
            @CSharpLua.Template = "gui.get_particlefx({0})"
            </summary>
        </member>
        <member name="M:Gui.get_inherit_alpha(types.Node)">
            <summary>
            gets the node inherit alpha state
            
            @CSharpLua.Template = "gui.get_inherit_alpha({0})"
            </summary>
        </member>
        <member name="M:Gui.set_inherit_alpha(types.Node,System.Boolean)">
            <summary>
            sets the node inherit alpha state
            
            @CSharpLua.Template = "gui.set_inherit_alpha({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.get_alpha(types.Node)">
            <summary>
            gets the node alpha
            
            @CSharpLua.Template = "gui.get_alpha({0})"
            </summary>
        </member>
        <member name="M:Gui.set_alpha(types.Node,System.Double)">
            <summary>
            sets the node alpha
            
            @CSharpLua.Template = "gui.set_alpha({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.init(System.Object)">
            <summary>
            This is a callback-function, which is called by the engine when a gui component is initialized. It can be used
            to set the initial state of the script and gui scene.
            
            @CSharpLua.Template = "gui.init({0})"
            </summary>
        </member>
        <member name="M:Gui.final(System.Object)">
            <summary>
            This is a callback-function, which is called by the engine when a gui component is finalized (destroyed). It can
            be used to e.g. take some last action, report the finalization to other game object instances
            or release user input focus (see <code>release_input_focus</code>). There is no use in starting any animations or similar
            from this function since the gui component is about to be destroyed.
            
            @CSharpLua.Template = "gui.final({0})"
            </summary>
        </member>
        <member name="M:Gui.update(System.Object,System.Double)">
            <summary>
            This is a callback-function, which is called by the engine every frame to update the state of a gui component.
            It can be used to perform any kind of gui related tasks, e.g. animating nodes.
            
            @CSharpLua.Template = "gui.update({0}, {1})"
            </summary>
        </member>
        <member name="M:Gui.on_message(System.Object,types.Hash,lua.LuaTableBase)">
            <summary>
            This is a callback-function, which is called by the engine whenever a message has been sent to the gui component.
            It can be used to take action on the message, e.g. update the gui or send a response back to the sender of the message.
            The <code>message</code> parameter is a table containing the message data. If the message is sent from the engine, the
            documentation of the message specifies which data is supplied.
            See the <a href="#update">update</a> function for examples on how to use this callback-function.
            
            @CSharpLua.Template = "gui.on_message({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.on_input(System.Object,types.Hash,lua.LuaTableBase)">
            <summary>
            This is a callback-function, which is called by the engine when user input is sent to the instance of the gui component.
            It can be used to take action on the input, e.g. modify the gui according to the input.
            For an instance to obtain user input, it must first acquire input
            focus through the message <code>acquire_input_focus</code>.
            Any instance that has obtained input will be put on top of an
            input stack. Input is sent to all listeners on the stack until the
            end of stack is reached, or a listener returns <code>true</code>
            to signal that it wants input to be consumed.
            See the documentation of <a href="/ref/go/#acquire_input_focus">acquire_input_focus</a> for more
            information.
            The <code>action</code> parameter is a table containing data about the input mapped to the
            <code>action_id</code>.
            For mapped actions it specifies the value of the input and if it was just pressed or released.
            Actions are mapped to input in an input_binding-file.
            Mouse movement is specifically handled and uses <code>nil</code> as its <code>action_id</code>.
            The <code>action</code> only contains positional parameters in this case, such as x and y of the pointer.
            Here is a brief description of the available table fields:
            <table>
            <thead>
            <tr>
            <th>Field</th>
            <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td><code>value</code></td>
            <td>The amount of input given by the user. This is usually 1 for buttons and 0-1 for analogue inputs. This is not present for mouse movement.</td>
            </tr>
            <tr>
            <td><code>pressed</code></td>
            <td>If the input was pressed this frame. This is not present for mouse movement.</td>
            </tr>
            <tr>
            <td><code>released</code></td>
            <td>If the input was released this frame. This is not present for mouse movement.</td>
            </tr>
            <tr>
            <td><code>repeated</code></td>
            <td>If the input was repeated this frame. This is similar to how a key on a keyboard is repeated when you hold it down. This is not present for mouse movement.</td>
            </tr>
            <tr>
            <td><code>x</code></td>
            <td>The x value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>y</code></td>
            <td>The y value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>screen_x</code></td>
            <td>The screen space x value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>screen_y</code></td>
            <td>The screen space y value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>dx</code></td>
            <td>The change in x value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>dy</code></td>
            <td>The change in y value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>screen_dx</code></td>
            <td>The change in screen space x value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>screen_dy</code></td>
            <td>The change in screen space y value of a pointer device, if present.</td>
            </tr>
            <tr>
            <td><code>gamepad</code></td>
            <td>The index of the gamepad device that provided the input.</td>
            </tr>
            <tr>
            <td><code>touch</code></td>
            <td>List of touch input, one element per finger, if present. See table below about touch input</td>
            </tr>
            </tbody>
            </table>
            Touch input table:
            <table>
            <thead>
            <tr>
            <th>Field</th>
            <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td><code>id</code></td>
            <td>A number identifying the touch input during its duration.</td>
            </tr>
            <tr>
            <td><code>pressed</code></td>
            <td>True if the finger was pressed this frame.</td>
            </tr>
            <tr>
            <td><code>released</code></td>
            <td>True if the finger was released this frame.</td>
            </tr>
            <tr>
            <td><code>tap_count</code></td>
            <td>Number of taps, one for single, two for double-tap, etc</td>
            </tr>
            <tr>
            <td><code>x</code></td>
            <td>The x touch location.</td>
            </tr>
            <tr>
            <td><code>y</code></td>
            <td>The y touch location.</td>
            </tr>
            <tr>
            <td><code>dx</code></td>
            <td>The change in x value.</td>
            </tr>
            <tr>
            <td><code>dy</code></td>
            <td>The change in y value.</td>
            </tr>
            <tr>
            <td><code>acc_x</code></td>
            <td>Accelerometer x value (if present).</td>
            </tr>
            <tr>
            <td><code>acc_y</code></td>
            <td>Accelerometer y value (if present).</td>
            </tr>
            <tr>
            <td><code>acc_z</code></td>
            <td>Accelerometer z value (if present).</td>
            </tr>
            </tbody>
            </table>
            
            @CSharpLua.Template = "gui.on_input({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Gui.on_reload(System.Object)">
            <summary>
            This is a callback-function, which is called by the engine when the gui script is reloaded, e.g. from the editor.
            It can be used for live development, e.g. to tweak constants or set up the state properly for the script.
            
            @CSharpLua.Template = "gui.on_reload({0})"
            </summary>
        </member>
        <member name="M:Gui.GetNode(types.Hash)">
            <summary>
            @CSharpLua.Template = "gui.get_node({0})"
            </summary>
        </member>
        <member name="T:Html5">
            <summary>
            HTML5 API documentation
            
            </summary>
        </member>
        <member name="M:Html5.run(System.String)">
            <summary>
            Executes the supplied string as JavaScript inside the browser.
            A call to this function is blocking, the result is returned as-is, as a string.
            (Internally this will execute the string using the <code>eval()</code> JavaScript function.)
            
            @CSharpLua.Template = "html5.run({0})"
            </summary>
        </member>
        <member name="M:Html5.set_interaction_listener">
            <summary>
            Set a JavaScript interaction listener callaback from lua that will be
            invoked when a user interacts with the web page by clicking, touching or typing.
            The callback can then call DOM restricted actions like requesting a pointer lock,
            or start playing sounds the first time the callback is invoked.
            
            @CSharpLua.Template = "html5.set_interaction_listener()"
            </summary>
        </member>
        <member name="T:Http">
            <summary>
            HTTP API documentation
            
            </summary>
        </member>
        <member name="M:Http.request(System.String,System.String,System.Action{System.Object,types.Hash,lua.LuaTable})">
            <summary>
            Perform a HTTP/HTTPS request.
            <span class="icon-attention"></span> If no timeout value is passed, the configuration value "network.http_timeout" is used. If that is not set, the timeout value is <code>0</code> (which blocks indefinitely).
            
            @CSharpLua.Template = "http.request({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Http.request(System.String,System.String,System.Action{System.Object,types.Hash,lua.LuaTable},lua.LuaTableBase)">
            <summary>
            Perform a HTTP/HTTPS request.
            <span class="icon-attention"></span> If no timeout value is passed, the configuration value "network.http_timeout" is used. If that is not set, the timeout value is <code>0</code> (which blocks indefinitely).
            
            @CSharpLua.Template = "http.request({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Http.request(System.String,System.String,System.Action{System.Object,types.Hash,lua.LuaTable},lua.LuaTableBase,System.String)">
            <summary>
            Perform a HTTP/HTTPS request.
            <span class="icon-attention"></span> If no timeout value is passed, the configuration value "network.http_timeout" is used. If that is not set, the timeout value is <code>0</code> (which blocks indefinitely).
            
            @CSharpLua.Template = "http.request({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Http.request(System.String,System.String,System.Action{System.Object,types.Hash,lua.LuaTable},lua.LuaTableBase,System.String,lua.LuaTableBase)">
            <summary>
            Perform a HTTP/HTTPS request.
            <span class="icon-attention"></span> If no timeout value is passed, the configuration value "network.http_timeout" is used. If that is not set, the timeout value is <code>0</code> (which blocks indefinitely).
            
            @CSharpLua.Template = "http.request({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="T:Iac">
            <summary>
            Inter-app communication API documentation
            
            </summary>
        </member>
        <member name="T:Iap">
            <summary>
            In-app purchases API documentation
            
            </summary>
        </member>
        <member name="T:Image">
            <summary>
            Image API documentation
            
            </summary>
        </member>
        <member name="M:Image.load(System.String)">
            <summary>
            Load image (PNG or JPEG) from buffer.
            
            @CSharpLua.Template = "image.load({0})"
            </summary>
        </member>
        <member name="M:Image.load(System.String,System.Boolean)">
            <summary>
            Load image (PNG or JPEG) from buffer.
            
            @CSharpLua.Template = "image.load({0}, {1})"
            </summary>
        </member>
        <member name="T:Json">
            <summary>
            JSON API documentation
            
            </summary>
        </member>
        <member name="M:Json.decode(System.String)">
            <summary>
            Decode a string of JSON data into a Lua table.
            A Lua error is raised for syntax errors.
            
            @CSharpLua.Template = "json.decode({0})"
            </summary>
        </member>
        <member name="M:Json.encode(lua.LuaTableBase)">
            <summary>
            Encode a lua table to a JSON string.
            A Lua error is raised for syntax errors.
            
            @CSharpLua.Template = "json.encode({0})"
            </summary>
        </member>
        <member name="T:Label">
            <summary>
            Label API documentation
            
            </summary>
        </member>
        <member name="M:Label.set_text(System.String,System.String)">
            <summary>
            Sets the text of a label component
            <span class="icon-attention"></span> This method uses the message passing that means the value will be set after <code>dispatch messages</code> step.
            More information is available in the <a href="/manuals/application-lifecycle">Application Lifecycle manual</a>.
            
            @CSharpLua.Template = "label.set_text({0}, {1})"
            </summary>
        </member>
        <member name="M:Label.set_text(types.Hash,System.String)">
            <summary>
            Sets the text of a label component
            <span class="icon-attention"></span> This method uses the message passing that means the value will be set after <code>dispatch messages</code> step.
            More information is available in the <a href="/manuals/application-lifecycle">Application Lifecycle manual</a>.
            
            @CSharpLua.Template = "label.set_text({0}, {1})"
            </summary>
        </member>
        <member name="M:Label.set_text(types.Url,System.String)">
            <summary>
            Sets the text of a label component
            <span class="icon-attention"></span> This method uses the message passing that means the value will be set after <code>dispatch messages</code> step.
            More information is available in the <a href="/manuals/application-lifecycle">Application Lifecycle manual</a>.
            
            @CSharpLua.Template = "label.set_text({0}, {1})"
            </summary>
        </member>
        <member name="M:Label.get_text(System.String)">
            <summary>
            Gets the text from a label component
            
            @CSharpLua.Template = "label.get_text({0})"
            </summary>
        </member>
        <member name="M:Label.get_text(types.Hash)">
            <summary>
            Gets the text from a label component
            
            @CSharpLua.Template = "label.get_text({0})"
            </summary>
        </member>
        <member name="M:Label.get_text(types.Url)">
            <summary>
            Gets the text from a label component
            
            @CSharpLua.Template = "label.get_text({0})"
            </summary>
        </member>
        <member name="T:lua.Debug">
            <summary>
            @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:lua.Debug.IsEditorDebug">
            <summary>
                @CSharpLua.Template = "sys.get_engine_info().is_debug"
            </summary>
        </member>
        <member name="M:lua.Debug._getHook(System.Object@,System.Object@)">
            <summary>
                @CSharpLua.Template = "debug.gethook()"
            </summary>
        </member>
        <member name="M:lua.Debug._setHook">
            <summary>
                @CSharpLua.Template = "debug.sethook()"
            </summary>
        </member>
        <member name="M:lua.Debug._setHook(System.Object,System.Object,System.Object)">
            <summary>
                @CSharpLua.Template = "debug.sethook({0},{1},{2})"
            </summary>
        </member>
        <member name="T:lua.LuaArrayOf`1">
            <summary>
            An array of a particular type.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:lua.LuaArrayOf`1.#ctor">
            <summary>
            @CSharpLua.Template = "{}"
            </summary>
        </member>
        <member name="T:lua.LuaArray">
            <summary>
            </summary>
        </member>
        <member name="M:lua.LuaArray.#ctor">
            <summary>
            @CSharpLua.Template = "{}"
            </summary>
        </member>
        <member name="M:lua.LuaArray.Create">
            <summary>
            @CSharpLua.Template = "{}"
            </summary>
        </member>
        <member name="M:lua.LuaArray.Create``1">
            <summary>
            @CSharpLua.Template = "{}"
            </summary>
        </member>
        <member name="M:lua.LuaArray.Create``1(``0[])">
            <summary>
            @CSharpLua.Template = "#{0}"
            </summary>
        </member>
        <member name="M:lua.LuaArray.Create``1(``0)">
            <summary>
            @CSharpLua.Template = "{{0}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0}, {1}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2},{3}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2},{3},{4}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0,``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2},{3},{4},{5}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2},{3},{4},{5},{6}}"
            </summary> 
        </member>
        <member name="M:lua.LuaArray.Create``1(``0,``0,``0,``0,``0,``0,``0,``0)">
            <summary>
            @CSharpLua.Template = "{{0},{1},{2},{3},{4},{5},{6},{7}}"
            </summary> 
        </member>
        <member name="M:lua.__LuaArrayExt.Count(lua.LuaArrayBase)">
            <summary>
            @CSharpLua.Template = "#{0}"
            </summary> 
        </member>
        <member name="M:lua.__LuaArrayExt.Add``1(lua.LuaArrayOf{``0},``0)">
            <summary>
            Adds the value to the end of the array.
            
            @CSharpLua.Template = "table.insert({0}, {1})"
            </summary>
            <param name="value">value to insert</param>
        </member>
        <member name="M:lua.__LuaArrayExt.Insert``1(lua.LuaArrayOf{``0},System.Int32,``0)">
            <summary>
            Inserts a value into the array at the specified position
            
            @CSharpLua.Template = "table.insert({0}, {1} + 1, {2})" 
            </summary>
            <param name="index">index to insert at</param>
            <param name="value">value to insert</param>
        </member>
        <member name="M:lua.__LuaArrayExt.Remove``1(lua.LuaArrayOf{``0},System.Int32)">
            <summary>
            Removes the element at the passed index
            
            @CSharpLua.Template = "table.remove({0}, {1} + 1)"
            </summary>
            <param name="index">index to remove</param>
            <returns></returns>
        </member>
        <member name="M:lua.__LuaArrayExt.RemoveLast``1(lua.LuaArrayOf{``0})">
            <summary>
            Removes the element at the passed index
            
            @CSharpLua.Template = "table.remove({0})"
            </summary>
            <param name="index">index to remove</param>
            <returns></returns>
        </member>
        <member name="M:lua.__LuaArrayExt.Sort(lua.LuaArrayBase)">
             <summary>
             Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table.
             the standard Lua operator 'less than' is used instead. The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.
            
             @CSharpLua.Template = "table.sort({0})"
             </summary>
        </member>
        <member name="M:lua.__LuaArrayExt.Sort``1(lua.LuaArrayOf{``0},System.Func{types.LuaType,types.LuaType,System.Boolean})">
             <summary>
             Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table.
             the standard Lua operator 'less than' is used instead. The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.
            
             @CSharpLua.Template = "table.sort({0}, {1})"
             </summary>
        </member>
        <member name="M:lua.__LuaArrayExt.concat(lua.LuaArrayBase)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together.
            
             @CSharpLua.Template = "table.concat({0})"
             <param name="table">The table to concatenate values</param>
             </summary>
        </member>
        <member name="M:lua.__LuaArrayExt.concat(lua.LuaArrayBase,System.String)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep.
            
             @CSharpLua.Template = "table.concat({0}, {1})"
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             </summary>
        </member>
        <member name="M:lua.__LuaArrayExt.concat(lua.LuaArrayBase,System.String,System.Int32)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep, starting with startOffset.
            
             @CSharpLua.Template = "table.concat({0}, {1}, {2} + 1)"
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             <param name="startOffset">The starting offset for the concatenation.  Zero-based.  ( + 1 in lua )</param>
             </summary>
        </member>
        <member name="M:lua.__LuaArrayExt.concat(lua.LuaArrayBase,System.String,System.Int32,System.Int32)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep, starting with startOffset and ending at endOffset.
            
             @CSharpLua.Template = "table.concat({0}, {1}, {2} + 1, {3} + 1)"
             </summary>
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             <param name="startOffset">The starting offset for the concatenation.  Zero-based.  ( + 1 in lua )</param>
             <param name="endOffset">The ending offset for the concatenation.  Defaults to the length of the table.  Zero-based. ( + 1 in lua )</param>
             <returns></returns>
        </member>
        <member name="T:lua.LuaTable">
            <summary>
            </summary>
        </member>
        <member name="M:lua.LuaTable.#ctor">
            <summary>
            Use one of the create methods instead.
            </summary>
        </member>
        <member name="M:lua.LuaTable.Create">
            <summary>
            @CSharpLua.Template = "{}"
            </summary> 
        </member>
        <member name="M:lua.LuaTable.Create``2">
            <summary>
            @CSharpLua.Template = "{}"
            </summary> 
        </member>
        <member name="M:lua.__LuaTableExt.Add``2(lua.LuaTableOf{``0,``1},``0,``1)">
            <summary>
            @CSharpLua.Template = "{0}[{1}] = {2}"
            </summary>
        </member>
        <member name="M:lua.__LuaTableExt.Remove``2(lua.LuaTableOf{``0,``1},``0)">
            <summary>
            @CSharpLua.Template = "{0}[{1}] = nil"
            </summary>
        </member>
        <member name="M:lua.__LuaTableExt.Clear(lua.LuaTableBase)">
            <summary>
            @CSharpLua.Template = for k in next, {0} do rawset({0}, k, nil) end
            </summary>
        </member>
        <member name="M:lua.__LuaTableExt.ContainsKey``2(lua.LuaTableOf{``0,``1},``0)">
            <summary>
            @CSharpLua.Template = "{0}[{1}]"
            </summary>
        </member>
        <member name="M:lua.__LuaTableExt.Get``2(lua.LuaTableOf{``0,``1},``0)">
            <summary>
            @CSharpLua.Template = "{0}[{1}]"
            </summary>
        </member>
        <member name="M:lua.__LuaTableExt.Set``2(lua.LuaTableOf{``0,``1},``0,``1)">
            <summary>
            @CSharpLua.Template = "{0}[{1}] = {2}"
            </summary>
        </member>
        <member name="T:lua.math">
             <summary>
             Lua math standard library
            
            	@CSharpLua.Ignore
             
             </summary>
        </member>
        <member name="M:lua.math.random">
            <summary>
            This function is an interface to the simple
            pseudo-random generator function rand provided by ANSI C.
            (No guarantees can be given for its statistical properties.)
            When called without arguments,
            returns a uniform pseudo-random real number
            in the range [0,1).
            When called with an integer number m,
            math.random returns
            a uniform pseudo-random integer in the range [1, m].
            When called with two integer numbers m and n,
            math.random returns a uniform pseudo-random
            integer in the range [m, n].
            
            @CSharpLua.Template = "math.random()"
            </summary>
        </member>
        <member name="M:lua.math.abs(System.Double)">
            <summary>
            @CSharpLua.Template = "math.abs({0})"
            </summary>
        </member>
        <member name="M:lua.math.acos(System.Double)">
            <summary>
            @CSharpLua.Template = "math.acos({0})"
            </summary>
        </member>
        <member name="M:lua.math.asin(System.Double)">
            <summary>
            @CSharpLua.Template = "math.asin({0})"
            </summary>
        </member>
        <member name="M:lua.math.atan(System.Double)">
            <summary>
            @CSharpLua.Template = "math.atan({0})"
            </summary>
        </member>
        <member name="M:lua.math.atan2(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.atan2({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.ceil(System.Double)">
            <summary>
            @CSharpLua.Template = "math.ceil({0})"
            </summary>
        </member>
        <member name="M:lua.math.cos(System.Double)">
            <summary>
            @CSharpLua.Template = "math.cos({0})"
            </summary>
        </member>
        <member name="M:lua.math.cosh(System.Double)">
            <summary>
            @CSharpLua.Template = "math.cosh({0})"
            </summary>
        </member>
        <member name="M:lua.math.deg(System.Double)">
            <summary>
            @CSharpLua.Template = "math.deg({0})"
            </summary>
        </member>
        <member name="M:lua.math.exp(System.Double)">
            <summary>
            @CSharpLua.Template = "math.exp({0})"
            </summary>
        </member>
        <member name="M:lua.math.floor(System.Double)">
            <summary>
            @CSharpLua.Template = "math.floor({0})"
            </summary>
        </member>
        <member name="M:lua.math.fmod(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.fmod({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.frexp(System.Double)">
            <summary>
            @CSharpLua.Template = "math.frexp({0})"
            </summary>
        </member>
        <member name="M:lua.math.ldexp(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.ldexp({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.log(System.Double)">
            <summary>
            @CSharpLua.Template = "math.log({0})"
            </summary>
        </member>
        <member name="M:lua.math.log10(System.Double)">
            <summary>
            @CSharpLua.Template = "math.log10({0})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4},{5})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4},{5},{6})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4},{5},{6},{7})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4},{5},{6},{7},{8})"
            </summary>
        </member>
        <member name="M:lua.math.max(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.max({0},{1},{2},{3},{4},{5},{6},{7},{8},{9})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4},{5})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4},{5},{6})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4},{5},{6},{7})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4},{5},{6},{7},{8})"
            </summary>
        </member>
        <member name="M:lua.math.min(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.min({0},{1},{2},{3},{4},{5},{6},{7},{8},{9})"
            </summary>
        </member>
        <member name="M:lua.math.modf(System.Double)">
            <summary>
            @CSharpLua.Template = "math.modf({0})"
            </summary>
        </member>
        <member name="M:lua.math.pow(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.pow({0},{1})"
            </summary>
        </member>
        <member name="M:lua.math.rad(System.Double)">
            <summary>
            @CSharpLua.Template = "math.rad({0})"
            </summary>
        </member>
        <member name="M:lua.math.random(System.Double)">
            <summary>
            @CSharpLua.Template = "math.random({0})"
            </summary>
        </member>
        <member name="M:lua.math.random(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "math.random({0}, {1})"
            </summary>
        </member>
        <member name="M:lua.math.random(System.Int32)">
            <summary>
            @CSharpLua.Template = "math.random({0})"
            </summary>
        </member>
        <member name="M:lua.math.random(System.Int32,System.Int32)">
            <summary>
            @CSharpLua.Template = "math.random({0}, {1})"
            </summary>
        </member>
        <member name="M:lua.math.randomseed(System.Double)">
            <summary>
            @CSharpLua.Template = "math.randomseed({0})"
            </summary>
        </member>
        <member name="M:lua.math.sin(System.Double)">
            <summary>
            @CSharpLua.Template = "math.sin({0})"
            </summary>
        </member>
        <member name="M:lua.math.sinh(System.Double)">
            <summary>
            @CSharpLua.Template = "math.sinh({0})"
            </summary>
        </member>
        <member name="M:lua.math.sqrt(System.Double)">
            <summary>
            @CSharpLua.Template = "math.sqrt({0})"
            </summary>
        </member>
        <member name="M:lua.math.tan(System.Double)">
            <summary>
            @CSharpLua.Template = "math.tan({0})"
            </summary>
        </member>
        <member name="M:lua.math.tanh(System.Double)">
            <summary>
            @CSharpLua.Template = "math.tan({0})"
            </summary>
        </member>
        <member name="M:lua.math.GetHuge">
            <summary>
            @CSharpLua.Template = "math.huge"
            </summary>
        </member>
        <member name="M:lua.math.GetPI">
            <summary>
            @CSharpLua.Template = "math.pi"
            </summary>
        </member>
        <member name="M:lua.math.GetTau">
            <summary>
            @CSharpLua.Template = "(2*math.pi)"
            </summary>
        </member>
        <member name="P:lua.math.TAU">
            <summary>
            The mathematically superior and far more intuitive constant.  2 x PI.   So, a quarter circle is TAU/4, half a circle is TAU/2, etc.  
            </summary>
        </member>
        <member name="T:lua.table">
            <summary>
            @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:lua.table.length(lua.LuaArrayBase)">
             <summary>
            
             @CSharpLua.Template = "#{0}"
             </summary> 
        </member>
        <member name="M:lua.table.concat(lua.LuaArrayBase)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together.
            
             @CSharpLua.Template = "table.concat({0})"
             <param name="table">The table to concatenate values</param>
             </summary>
        </member>
        <member name="M:lua.table.concat(lua.LuaArrayBase,System.String)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep.
            
             @CSharpLua.Template = "table.concat({0}, {1})"
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             </summary>
        </member>
        <member name="M:lua.table.concat(lua.LuaArrayBase,System.String,System.Int32)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep, starting with startOffset.
            
             @CSharpLua.Template = "table.concat({0}, {1}, {2} + 1)"
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             <param name="startOffset">The starting offset for the concatenation.  Zero-based.  ( + 1 in lua )</param>
             </summary>
        </member>
        <member name="M:lua.table.concat(lua.LuaArrayBase,System.String,System.Int32,System.Int32)">
             <summary>
             Given an array where all elements are strings or numbers, concatenates all of them together, separated by sep, starting with startOffset and ending at endOffset.
            
             @CSharpLua.Template = "table.concat({0}, {1}, {2} + 1, {3} + 1)"
             </summary>
             <param name="table">The table to concatenate values</param>
             <param name="separator">The separator to insert between elements.</param>
             <param name="startOffset">The starting offset for the concatenation.  Zero-based.  ( + 1 in lua )</param>
             <param name="endOffset">The ending offset for the concatenation.  Defaults to the length of the table.  Zero-based. ( + 1 in lua )</param>
             <returns></returns>
        </member>
        <member name="M:lua.table.insert``1(lua.LuaArrayBase,``0)">
             <summary>
             Inserts a value at the end of the table.
            
             @CSharpLua.Template = "table.insert({0}, {1})"
             </summary>
             <param name="table">The table to insert values into</param>
             <param name="value">The value to insert</param>
        </member>
        <member name="M:lua.table.insert``1(lua.LuaArrayBase,System.Int32,``0)">
             <summary>
             Inserts a value at a position in the table, shifting up other elements to open space, if necessary.
            
             @CSharpLua.Template = "table.insert({0}, {1} + 1, {2})" 
             </summary>
             <param name="table">The table to insert values into</param>
             <param name="pos">The position to insert at.  Zero-based</param>
             <param name="value">The value to insert</param>
             <typeparam name="T"></typeparam>
        </member>
        <member name="M:lua.table.maxn(lua.LuaArrayBase)">
             <summary>
             Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices. (To do its job this function does a linear traversal of the whole table.)
            
             @CSharpLua.Template = "table.maxn({0})"
             </summary>
             <param name="table">The table to scan</param>
        </member>
        <member name="M:lua.table.remove(lua.LuaArrayBase)">
             <summary>
             Removes the last element of the table.
            
             @CSharpLua.Template = "table.remove({0})"
             </summary>
             <param name="table">The table to trim</param>
        </member>
        <member name="M:lua.table.remove(lua.LuaArrayBase,System.Int32)">
             <summary>
             Removes from table the element at position pos, shifting down other elements to close the space, if necessary. Returns the value of the removed element
            
             @CSharpLua.Template = "table.remove({0}, {1} + 1)"
             </summary>
             <param name="pos">The position to remove.  Zero-based</param>
             <param name="table">The table to trim</param>
        </member>
        <member name="M:lua.table.sort(lua.LuaArrayBase)">
             <summary>
             Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table.
             the standard Lua operator 'less than' is used instead. The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.
            
             @CSharpLua.Template = "table.sort({0})"
             </summary>
             <param name="table">The table to sort</param>
        </member>
        <member name="M:lua.table.sort(lua.LuaArrayBase,System.Func{types.ILuaType,types.ILuaType,System.Boolean})">
             <summary>
             Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table.
             the standard Lua operator 'less than' is used instead. The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.
            
             @CSharpLua.Template = "table.sort({0}, {1})"
             </summary>
             <param name="table">The table to sort</param>
        </member>
        <member name="T:types.LuaType">
            <summary>
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(types.Url)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(types.Hash)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.String)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.Int32)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.Single)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.Int64)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.Double)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(types.vector2)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(types.vector3)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(types.vector4)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(System.Boolean)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(lua.LuaArrayBase)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.LuaType.op_Implicit(lua.LuaTableBase)~types.LuaType">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.__LuaTypeExt.AsLuaType(types.ILuaType)">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>		
        </member>
        <member name="T:types.AdjustMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.BlendFunction">
            <summary>
            </summary>
        </member>
        <member name="T:types.BlendMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.BufferStream">
            <summary>
            </summary>
        </member>
        <member name="T:types.ClippingMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.ConstantBuffer">
            <summary>
            </summary>
        </member>
        <member name="T:types.DataBuffer">
            <summary>
            </summary>
        </member>
        <member name="T:types.DepthFunction">
            <summary>
            </summary>
        </member>
        <member name="T:types.Easing">
            <summary>
            </summary>
        </member>
        <member name="T:types.FaceType">
            <summary>
            </summary>
        </member>
        <member name="T:types.FactoryStatus">
            <summary>
            </summary>
        </member>
        <member name="T:types.GoPlaybackMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.GuiAnchor">
            <summary>
            </summary>
        </member>
        <member name="T:types.GuiPivot">
            <summary>
            </summary>
        </member>
        <member name="T:types.GuiPlaybackMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.GuiProperty">
            <summary>
            </summary>
        </member>
        <member name="T:types.GuiTextureType">
            <summary>
            </summary>
        </member>
        <member name="T:types.Hash">
            <summary>
            </summary>
        </member>
        <member name="M:types.Hash.op_Implicit(System.String)~types.Hash">
            <summary>
            @CSharpLua.Template = "hash({0})"
            </summary>
        </member>
        <member name="M:types.Hash.op_Implicit(types.Hash)~System.String">
            <summary>
            @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="M:types.Hash.ToString">
            <summary>
            @CSharpLua.Template = "{this}"
            </summary>
        </member>
        <member name="T:types.__Hash2">
            <summary>
            //Used so we can fool the C# compiler into allowing us more overrides.  Hash is the actual implementation and should be
            used in methods where possible.
            </summary>
        </member>
        <member name="M:types.__Hash2.op_Implicit(types.Hash)~types.__Hash2">
            <summary>
            @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:types.__Hash2.op_Implicit(System.String)~types.__Hash2">
            <summary>
            @CSharpLua.Template = "hash({0})"
            </summary>
        </member>
        <member name="M:types.__Hash2.ToHash">
            <summary>
            @CSharpLua.Template = "{this}"
            </summary>
        </member>
        <member name="T:types.__Hash3">
            <summary>
            //Used so we can fool the C# compiler into allowing us more overrides.  Hash is the actual implementation and should be
            used in methods where possible.
            </summary>
        </member>
        <member name="M:types.__Hash3.op_Implicit(types.Hash)~types.__Hash3">
            <summary>
            @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:types.__Hash3.op_Implicit(System.String)~types.__Hash3">
            <summary>
            @CSharpLua.Template = "hash({0})"
            </summary>
        </member>
        <member name="M:types.__Hash3.ToHash">
            <summary>
            @CSharpLua.Template = "{this}"
            </summary>
        </member>
        <member name="T:types.ILuaTableSerializable">
            <summary>
            </summary>
        </member>
        <member name="T:types.KeyboardType">
            <summary>
            </summary>
        </member>
        <member name="T:types.Matrix4">
            <summary>
            </summary>
        </member>
        <member name="M:types.Matrix4.#ctor">
            <summary>
            @CSharpLua.Template = "vmath.matrix4()"
            </summary>
        </member>
        <member name="M:types.Matrix4.Clone(types.Matrix4)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_axis_angle(types.vector3,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_axis_angle({0},{1})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_quat(types.Quaternion)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_from_quat({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_frustum(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_frustum({0},{1},{2},{3},{4},{5})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_look_at(types.vector3,types.vector3,types.vector3)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_look_at({0},{1},{2})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_orthographic(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_orthographic({0},{1},{2},{3},{4},{5})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_perspective(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_perspective({0},{1},{2},{3})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_rotation_x(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_rotation_x({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_rotation_y(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_rotation_y({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_rotation_z(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_rotation_z({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_translation(types.vector3)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_translation({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.From_translation(types.vector4)">
            <summary>
            @CSharpLua.Template = "vmath.matrix4_translation({0})"
            </summary>
        </member>
        <member name="M:types.Matrix4.op_Multiply(types.Matrix4,System.Single)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.Matrix4.op_Multiply(System.Single,types.Matrix4)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.Matrix4.op_Multiply(types.Matrix4,types.Matrix4)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.Matrix4.op_Multiply(types.Matrix4,types.vector4)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.Matrix4.op_Multiply(types.vector4,types.Matrix4)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.Matrix4.OrthoInv">
            <summary>
            @CSharpLua.Template = "vmath.ortho_inv({this})"
            </summary>
        </member>
        <member name="T:types.Node">
            <summary>
            </summary>
        </member>
        <member name="M:types.Node.SetEnabled(System.Boolean)">
            <summary>
            @CSharpLua.Template = "gui.set_enabled({this}, {0})"
            </summary>
        </member>
        <member name="T:types.ParticleEmitterState">
            <summary>
            </summary>
        </member>
        <member name="T:types.PieBounds">
            <summary>
            </summary>
        </member>
        <member name="T:types.PlaybackMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.ProfilerMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.ProfilerViewMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.Quaternion">
            <summary>
            </summary>
        </member>
        <member name="M:types.Quaternion.#ctor">
            <summary>
            @CSharpLua.Template = "vmath.quat()"
            </summary>
        </member>
        <member name="M:types.Quaternion.#ctor(types.Quaternion)">
            <summary>
            @CSharpLua.Template = "vmath.quat({0})"
            </summary>
        </member>
        <member name="M:types.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.quat({0},{1},{2},{3})"
            </summary>
        </member>
        <member name="M:types.Quaternion.From_axis_angle(types.vector3,System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.quat_axis_angle({0},{1})"
            </summary>
        </member>
        <member name="M:types.Quaternion.From_basis(types.vector3,types.vector3,types.vector3)">
            <summary>
            @CSharpLua.Template = "vmath.quat_basis({0},{1},{2})"
            </summary>
        </member>
        <member name="M:types.Quaternion.From_to(types.vector3,types.vector3)">
            <summary>
            @CSharpLua.Template = "vmath.quat_from_to({0},{1})"
            </summary>
        </member>
        <member name="M:types.Quaternion.Rotation_x(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.quat_rotation_x({0})"
            </summary>
        </member>
        <member name="M:types.Quaternion.Rotation_y(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.quat_rotation_y({0})"
            </summary>
        </member>
        <member name="M:types.Quaternion.Rotation_z(System.Single)">
            <summary>
            @CSharpLua.Template = "vmath.quat_rotation_z({0})"
            </summary>
        </member>
        <member name="M:types.Quaternion.RotateVector(types.vector3)">
            <summary>
            @CSharpLua.Template = "vmath.rotate({this},{0})"
            </summary>
        </member>
        <member name="M:types.Quaternion.op_Multiply(types.Quaternion,types.Quaternion)">
            <summary>
            @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="T:types.Rect">
            <summary>
            </summary>
        </member>
        <member name="T:types.RenderState">
            <summary>
            </summary>
        </member>
        <member name="T:types.ResourceLiveUpdate">
            <summary>
            </summary>
        </member>
        <member name="T:types.SizeMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.StencilOperator">
            <summary>
            </summary>
        </member>
        <member name="T:types.SysConnectivity">
            <summary>
            </summary>
        </member>
        <member name="T:types.TilemapTransforms">
            <summary>
            </summary>
        </member>
        <member name="T:types.TimeStepMode">
            <summary>
            </summary>
        </member>
        <member name="T:types.Url">
            <summary>
            </summary>
        </member>
        <member name="M:types.Url.#ctor">
            <summary>
            @CSharpLua.Template = "msg.url()"
            </summary>
        </member>
        <member name="M:types.Url.#ctor(System.String)">
            <summary>
            @CSharpLua.Template = "msg.url({0})"
            </summary>
        </member>
        <member name="M:types.Url.#ctor(System.String,System.String,System.String)">
            <summary>
            @CSharpLua.Template = "msg.url({0},{1},{2})"
            </summary>
        </member>
        <member name="T:types.vector2">
            <summary>
            </summary>
        </member>
        <member name="M:types.vector2.#ctor">
            <summary>
                @CSharpLua.Template = "vmath.vector3()"
            </summary>
        </member>
        <member name="M:types.vector2.#ctor(System.Double,System.Double)">
            <summary>
                @CSharpLua.Template = "vmath.vector3({0},{1},0)"
            </summary>
        </member>
        <member name="M:types.vector2.op_Addition(types.vector2,types.vector2)">
            <summary>
                @CSharpLua.Template = "{0} + {1}"
            </summary>
        </member>
        <member name="M:types.vector2.op_Subtraction(types.vector2,types.vector2)">
            <summary>
                @CSharpLua.Template = "{0} - {1}"
            </summary>
        </member>
        <member name="M:types.vector2.neg(types.vector2)">
            <summary>
                @CSharpLua.Template = "-{0}"
            </summary>
        </member>
        <member name="M:types.vector2.op_Multiply(types.vector2,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector2.op_Multiply(System.Double,types.vector2)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector2.op_Multiply(types.vector2,types.vector2)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector2.op_Division(types.vector2,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} / {1}"
            </summary>
        </member>
        <member name="M:types.vector2.Magnitude">
            <summary>
                @CSharpLua.Template = "vmath.length({this})"
            </summary>
        </member>
        <member name="M:types.vector2.MagnitudeSqr">
            <summary>
                @CSharpLua.Template = "vmath.length_sqr({this})"
            </summary>
        </member>
        <member name="M:types.vector2.MultiplyByElement(types.vector3)">
            <summary>
                @CSharpLua.Template = "vmath.mul_per_elem({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector2.Normalize">
            <summary>
                @CSharpLua.Template = "vmath.normalize({this})"
            </summary>
        </member>
        <member name="M:types.vector2.Project(types.vector2)">
            <summary>
                @CSharpLua.Template = "vmath.project({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector2.Project(types.vector3)">
            <summary>
                @CSharpLua.Template = "vmath.project({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector2.op_Implicit(types.vector2)~types.vector3">
            <summary>
                @CSharpLua.Template = "{0}"
            </summary>
        </member>
        <member name="T:types.vector3">
            <summary>
            </summary>
        </member>
        <member name="M:types.vector3.#ctor">
            <summary>
                @CSharpLua.Template = "vmath.vector3()"
            </summary>
        </member>
        <member name="M:types.vector3.#ctor(System.Double,System.Double,System.Double)">
            <summary>
                @CSharpLua.Template = "vmath.vector3({0},{1},{2})"
            </summary>
        </member>
        <member name="M:types.vector3.op_Addition(types.vector3,types.vector3)">
            <summary>
                @CSharpLua.Template = "{0} + {1}"
            </summary>
        </member>
        <member name="M:types.vector3.op_Subtraction(types.vector3,types.vector3)">
            <summary>
                @CSharpLua.Template = "{0} - {1}"
            </summary>
        </member>
        <member name="M:types.vector3.neg(types.vector3)">
            <summary>
                @CSharpLua.Template = "-{0}"
            </summary>
        </member>
        <member name="M:types.vector3.op_Multiply(types.vector3,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector3.op_Multiply(System.Double,types.vector3)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector3.op_Multiply(types.vector3,types.vector3)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector3.op_Division(types.vector3,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} / {1}"
            </summary>
        </member>
        <member name="M:types.vector3.Magnitude">
            <summary>
                @CSharpLua.Template = "vmath.length({this})"
            </summary>
        </member>
        <member name="M:types.vector3.MagnitudeSqr">
            <summary>
                @CSharpLua.Template = "vmath.length_sqr({this})"
            </summary>
        </member>
        <member name="M:types.vector3.MultiplyByElement(types.vector3)">
            <summary>
                @CSharpLua.Template = "vmath.mul_per_elem({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector3.Normalize">
            <summary>
                @CSharpLua.Template = "vmath.normalize({this})"
            </summary>
        </member>
        <member name="M:types.vector3.Project(types.vector3)">
            <summary>
                @CSharpLua.Template = "vmath.project({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector3.Tovector2">
            <summary>
                @CSharpLua.Template = "{this}"
            </summary>
        </member>
        <member name="T:types.vector4">
            <summary>
            </summary>
        </member>
        <member name="M:types.vector4.#ctor">
            <summary>
                @CSharpLua.Template = "vmath.vector4()"
            </summary>
        </member>
        <member name="M:types.vector4.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                @CSharpLua.Template = "vmath.vector4({0},{1},{2},{3})"
            </summary>
        </member>
        <member name="M:types.vector4.op_Addition(types.vector4,types.vector4)">
            <summary>
                @CSharpLua.Template = "{0} + {1}"
            </summary>
        </member>
        <member name="M:types.vector4.op_Subtraction(types.vector4,types.vector4)">
            <summary>
                @CSharpLua.Template = "{0} - {1}"
            </summary>
        </member>
        <member name="M:types.vector4.neg(types.vector4)">
            <summary>
                @CSharpLua.Template = "-{0}"
            </summary>
        </member>
        <member name="M:types.vector4.op_Multiply(types.vector4,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector4.op_Multiply(System.Double,types.vector4)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector4.op_Multiply(types.vector4,types.vector4)">
            <summary>
                @CSharpLua.Template = "{0} * {1}"
            </summary>
        </member>
        <member name="M:types.vector4.op_Division(types.vector4,System.Double)">
            <summary>
                @CSharpLua.Template = "{0} / {1}"
            </summary>
        </member>
        <member name="M:types.vector4.Magnitude">
            <summary>
                @CSharpLua.Template = "vmath.length({this})"
            </summary>
        </member>
        <member name="M:types.vector4.MagnitudeSqr">
            <summary>
                @CSharpLua.Template = "vmath.length_sqr({this})"
            </summary>
        </member>
        <member name="M:types.vector4.MultiplyByElement(types.vector4)">
            <summary>
                @CSharpLua.Template = "vmath.mul_per_elem({this},{0})"
            </summary>
        </member>
        <member name="M:types.vector4.Normalize">
            <summary>
                @CSharpLua.Template = "vmath.normalize({this})"
            </summary>
        </member>
        <member name="T:types.WindowDimming">
            <summary>
            </summary>
        </member>
        <member name="T:types.WindowEvent">
            <summary>
            </summary>
        </member>
        <member name="M:Message.post(System.String,System.String)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1})
            </summary>
        </member>
        <member name="M:Message.post(types.Url,System.String)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1})
            </summary>
        </member>
        <member name="M:Message.post(types.Hash,System.String)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1})
            </summary>
        </member>
        <member name="M:Message.post(System.String,System.String,lua.LuaTable)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1},{2})
            </summary>
        </member>
        <member name="M:Message.post(types.Url,System.String,lua.LuaTable)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1},{2})
            </summary>
        </member>
        <member name="M:Message.post(types.Hash,System.String,lua.LuaTable)">
            <summary>
                @CSharpLua.Template = msg.post({0},{1},{2})
            </summary>
        </member>
        <member name="T:Model">
            <summary>
            Model API documentation
            
            </summary>
        </member>
        <member name="T:Model.model_animation_done_message">
            <summary>
            </summary>
        </member>
        <member name="M:Model.cancel(System.String)">
            <summary>
            Cancels all animation on a model component.
            
            @CSharpLua.Template = "model.cancel({0})"
            </summary>
        </member>
        <member name="M:Model.cancel(types.Hash)">
            <summary>
            Cancels all animation on a model component.
            
            @CSharpLua.Template = "model.cancel({0})"
            </summary>
        </member>
        <member name="M:Model.cancel(types.Url)">
            <summary>
            Cancels all animation on a model component.
            
            @CSharpLua.Template = "model.cancel({0})"
            </summary>
        </member>
        <member name="M:Model.get_go(System.String,System.String)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="M:Model.get_go(System.String,types.Hash)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="M:Model.get_go(types.Hash,System.String)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="M:Model.get_go(types.Hash,types.Hash)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="M:Model.get_go(types.Url,System.String)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="M:Model.get_go(types.Url,types.Hash)">
            <summary>
            Gets the id of the game object that corresponds to a model skeleton bone.
            The returned game object can be used for parenting and transform queries.
            This function has complexity <code>O(n)</code>, where <code>n</code> is the number of bones in the model skeleton.
            Game objects corresponding to a model skeleton bone can not be individually deleted.
            
            @CSharpLua.Template = "model.get_go({0}, {1})"
            </summary>
        </member>
        <member name="T:Msg">
            <summary>
            Messaging API documentation
            
            </summary>
        </member>
        <member name="M:Msg.url">
            <summary>
            This is equivalent to <code>msg.url(nil)</code> or <code>msg.url("#")</code>, which creates an url to the current
            script component.
            
            @CSharpLua.Template = "msg.url()"
            </summary>
        </member>
        <member name="M:Msg.url(System.String)">
            <summary>
            The format of the string must be <code>[socket:][path][#fragment]</code>, which is similar to a HTTP URL.
            When addressing instances:
            <ul>
            <li><code>socket</code> is the name of a valid world (a collection)</li>
            <li><code>path</code> is the id of the instance, which can either be relative the instance of the calling script or global</li>
            <li><code>fragment</code> would be the id of the desired component</li>
            </ul>
            In addition, the following shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            
            @CSharpLua.Template = "msg.url({0})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,System.String,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,System.String,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,types.Hash,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(System.String,types.Hash,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,System.String,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,System.String,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,types.Hash,System.String)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.url(types.Hash,types.Hash,types.Hash)">
            <summary>
            creates a new URL from separate arguments
            
            @CSharpLua.Template = "msg.url({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(System.String,System.String)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(System.String,System.String,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(System.String,types.Hash)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(System.String,types.Hash,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Url,System.String)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Url,System.String,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Url,types.Hash)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Url,types.Hash,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Hash,System.String)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Hash,System.String,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Hash,types.Hash)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1})"
            </summary>
        </member>
        <member name="M:Msg.post(types.Hash,types.Hash,lua.LuaTableBase)">
            <summary>
            Post a message to a receiving URL. The most common case is to send messages
            to a component. If the component part of the receiver is omitted, the message
            is broadcast to all components in the game object.
            The following receiver shorthands are available:
            <ul>
            <li><code>"."</code> the current game object</li>
            <li><code>"#"</code> the current component</li>
            </ul>
            <span class="icon-attention"></span> There is a 2 kilobyte limit to the message parameter table size.
            
            @CSharpLua.Template = "msg.post({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:OS.clock">
            <summary>
            @CSharpLua.Template = "os.clock()"
            </summary>
        </member>
        <member name="M:OS.date">
            <summary>
            @CSharpLua.Template = "os.date({0},{1})"
            </summary>
        </member>
        <member name="M:OS.date(System.String)">
            <summary>
            @CSharpLua.Template = "os.date({0})"
            </summary>
        </member>
        <member name="M:OS.difftime(System.Double,System.Double)">
            <summary>
            @CSharpLua.Template = "os.difftime({0},{1})"
            </summary>
        </member>
        <member name="M:OS.execute(System.String)">
            <summary>
            @CSharpLua.Template = "os.execute({0})"
            </summary>
        </member>
        <member name="M:OS.IsShellAvailable">
            <summary>
            @CSharpLua.Template = "(os.execute() ~= 0)"
            </summary>
        </member>
        <member name="M:OS.Shutdown">
            <summary>
            Safely shuts the game down.  Use exit() if an immediate force exit is needed
            </summary>
        </member>
        <member name="M:OS.exit">
            <summary>
            @CSharpLua.Template = "os.exit()"
            </summary>
        </member>
        <member name="M:OS.exit(System.Int32)">
            <summary>
            @CSharpLua.Template = "os.exit({0})"
            </summary>
        </member>
        <member name="M:OS.getenv(System.String)">
            <summary>
            @CSharpLua.Template = "os.getenv({0})"
            </summary>
        </member>
        <member name="M:OS.remove(System.String,System.String@)">
            <summary>
            @CSharpLua.Template = "os.remove({0})"
            </summary>
        </member>
        <member name="M:OS.rename(System.String,System.String,System.String@)">
            <summary>
            @CSharpLua.Template = "os.rename({0},{1})"
            </summary>
        </member>
        <member name="M:OS.setlocale">
            <summary>
            @CSharpLua.Template = "os.setlocale(nil)"
            </summary>
        </member>
        <member name="M:OS.getlocale">
            <summary>
            @CSharpLua.Template = "os.setlocale(nil)"
            </summary>
        </member>
        <member name="M:OS.setlocale(System.String)">
            <summary>
            @CSharpLua.Template = "os.setlocale({0})"
            </summary>
        </member>
        <member name="M:OS.setlocale(System.String,System.String)">
            <summary>
            @CSharpLua.Template = "os.setlocale({0},{1})"
            </summary>
        </member>
        <member name="M:OS.time">
            <summary>
            @CSharpLua.Template = "os.time()"
            </summary>
        </member>
        <member name="M:OS.time(lua.LuaTable)">
            <summary>
            @CSharpLua.Template = "os.time({0})"
            </summary>
        </member>
        <member name="M:OS.tmpname">
            <summary>
            @CSharpLua.Template = "os.time()"
            </summary>
        </member>
        <member name="T:Particlefx">
            <summary>
            Particle effects API documentation
            
            </summary>
        </member>
        <member name="M:Particlefx.play(System.String)">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0})"
            </summary>
        </member>
        <member name="M:Particlefx.play(System.String,System.Action{System.Object,types.Hash,types.Hash,types.ParticleEmitterState})">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.play(types.Hash)">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0})"
            </summary>
        </member>
        <member name="M:Particlefx.play(types.Hash,System.Action{System.Object,types.Hash,types.Hash,types.ParticleEmitterState})">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.play(types.Url)">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0})"
            </summary>
        </member>
        <member name="M:Particlefx.play(types.Url,System.Action{System.Object,types.Hash,types.Hash,types.ParticleEmitterState})">
            <summary>
            Starts playing a particle FX component.
            Particle FX started this way need to be manually stopped through <code>particlefx.stop()</code>.
            Which particle FX to play is identified by the URL.
            <span class="icon-attention"></span> A particle FX will continue to emit particles even if the game object the particle FX component belonged to is deleted. You can call <code>particlefx.stop()</code> to stop it from emitting more particles.
            
            @CSharpLua.Template = "particlefx.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.stop(System.String,lua.LuaTableBase)">
            <summary>
            Stops a particle FX component from playing.
            Stopping a particle FX does not remove already spawned particles.
            Which particle FX to stop is identified by the URL.
            
            @CSharpLua.Template = "particlefx.stop({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.stop(types.Hash,lua.LuaTableBase)">
            <summary>
            Stops a particle FX component from playing.
            Stopping a particle FX does not remove already spawned particles.
            Which particle FX to stop is identified by the URL.
            
            @CSharpLua.Template = "particlefx.stop({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.stop(types.Url,lua.LuaTableBase)">
            <summary>
            Stops a particle FX component from playing.
            Stopping a particle FX does not remove already spawned particles.
            Which particle FX to stop is identified by the URL.
            
            @CSharpLua.Template = "particlefx.stop({0}, {1})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(System.String,System.String,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(System.String,System.String,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(System.String,types.Hash,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(System.String,types.Hash,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Hash,System.String,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Hash,System.String,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Hash,types.Hash,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Hash,types.Hash,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Url,System.String,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Url,System.String,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Url,types.Hash,System.String,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.set_constant(types.Url,types.Hash,types.Hash,types.vector4)">
            <summary>
            Sets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Setting a constant through this function will override the value set for that constant in the material.
            The value will be overridden until particlefx.reset_constant is called.
            Which particle FX to set a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.set_constant({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(System.String,System.String,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(System.String,System.String,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(System.String,types.Hash,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(System.String,types.Hash,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Hash,System.String,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Hash,System.String,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Hash,types.Hash,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Hash,types.Hash,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Url,System.String,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Url,System.String,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Url,types.Hash,System.String)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Particlefx.reset_constant(types.Url,types.Hash,types.Hash)">
            <summary>
            Resets a shader constant for a particle FX component emitter.
            The constant must be defined in the material assigned to the emitter.
            Resetting a constant through this function implies that the value defined in the material will be used.
            Which particle FX to reset a constant for is identified by the URL.
            
            @CSharpLua.Template = "particlefx.reset_constant({0}, {1}, {2})"
            </summary>
        </member>
        <member name="T:Physics">
            <summary>
            Collision object physics API documentation
            
            </summary>
        </member>
        <member name="T:Physics.apply_force_message">
            <summary>
            </summary>
        </member>
        <member name="T:Physics.collision_response_message">
            <summary>
            </summary>
        </member>
        <member name="T:Physics.contact_point_response_message">
            <summary>
            </summary>
        </member>
        <member name="T:Physics.trigger_response_message">
            <summary>
            </summary>
        </member>
        <member name="T:Physics.ray_cast_response_message">
            <summary>
            </summary>
        </member>
        <member name="T:Physics.ray_cast_missed_message">
            <summary>
            </summary>
        </member>
        <member name="M:Physics.raycast_async(types.vector3,types.vector3,lua.LuaTableBase)">
            <summary>
            Ray casts are used to test for intersections against collision objects in the physics world.
            Collision objects of types kinematic, dynamic and static are tested against. Trigger objects
            do not intersect with ray casts.
            Which collision objects to hit is filtered by their collision groups and can be configured
            through <code>groups</code>.
            The actual ray cast will be performed during the physics-update.
            <ul>
            <li>If an object is hit, the result will be reported via a <code>ray_cast_response</code> message.</li>
            <li>If there is no object hit, the result will be reported via a <code>ray_cast_missed</code> message.</li>
            </ul>
            
            @CSharpLua.Template = "physics.raycast_async({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.raycast_async(types.vector3,types.vector3,lua.LuaTableBase,System.Double)">
            <summary>
            Ray casts are used to test for intersections against collision objects in the physics world.
            Collision objects of types kinematic, dynamic and static are tested against. Trigger objects
            do not intersect with ray casts.
            Which collision objects to hit is filtered by their collision groups and can be configured
            through <code>groups</code>.
            The actual ray cast will be performed during the physics-update.
            <ul>
            <li>If an object is hit, the result will be reported via a <code>ray_cast_response</code> message.</li>
            <li>If there is no object hit, the result will be reported via a <code>ray_cast_missed</code> message.</li>
            </ul>
            
            @CSharpLua.Template = "physics.raycast_async({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Physics.raycast(types.vector3,types.vector3,lua.LuaTableBase,lua.LuaTableBase)">
            <summary>
            Ray casts are used to test for intersections against collision objects in the physics world.
            Collision objects of types kinematic, dynamic and static are tested against. Trigger objects
            do not intersect with ray casts.
            Which collision objects to hit is filtered by their collision groups and can be configured
            through <code>groups</code>.
            
            @CSharpLua.Template = "physics.raycast({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,System.String,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,System.String,types.Hash,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,System.String,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Hash,types.Hash,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,System.String,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,System.String,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,System.String,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,types.Hash,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,types.Hash,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,types.Url,types.vector3)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Physics.create_joint(System.Double,types.Url,types.Hash,types.vector3,types.Url,types.vector3,lua.LuaTableBase)">
            <summary>
            Create a physics joint between two collision object components.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.create_joint({0}, {1}, {2}, {3}, {4}, {5}, {6})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(System.String,System.String)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(System.String,types.Hash)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(types.Hash,System.String)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(types.Hash,types.Hash)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(types.Url,System.String)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.destroy_joint(types.Url,types.Hash)">
            <summary>
            Destroy an already physics joint. The joint has to be created before a
            destroy can be issued.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.destroy_joint({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(System.String,System.String)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(System.String,types.Hash)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(types.Hash,System.String)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(types.Hash,types.Hash)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(types.Url,System.String)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_properties(types.Url,types.Hash)">
            <summary>
            Get a table for properties for a connected joint. The joint has to be created before
            properties can be retrieved.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_properties({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(System.String,System.String,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(System.String,types.Hash,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(types.Hash,System.String,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(types.Hash,types.Hash,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(types.Url,System.String,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_joint_properties(types.Url,types.Hash,lua.LuaTableBase)">
            <summary>
            Updates the properties for an already connected joint. The joint has to be created before
            properties can be changed.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.set_joint_properties({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(System.String,System.String)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(System.String,types.Hash)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(types.Hash,System.String)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(types.Hash,types.Hash)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(types.Url,System.String)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_force(types.Url,types.Hash)">
            <summary>
            Get the reaction force for a joint. The joint has to be created before
            the reaction force can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_force({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(System.String,System.String)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(System.String,types.Hash)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(types.Hash,System.String)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(types.Hash,types.Hash)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(types.Url,System.String)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_joint_reaction_torque(types.Url,types.Hash)">
            <summary>
            Get the reaction torque for a joint. The joint has to be created before
            the reaction torque can be calculated.
            Note: Currently only supported in 2D physics.
            
            @CSharpLua.Template = "physics.get_joint_reaction_torque({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_gravity(types.vector3)">
            <summary>
            Set the gravity in runtime. The gravity change is not global, it will only affect
            the collection that the function is called from.
            Note: For 2D physics the z component of the gravity vector will be ignored.
            
            @CSharpLua.Template = "physics.set_gravity({0})"
            </summary>
        </member>
        <member name="M:Physics.get_gravity">
            <summary>
            Get the gravity in runtime. The gravity returned is not global, it will return
            the gravity for the collection that the function is called from.
            Note: For 2D physics the z component will always be zero.
            
            @CSharpLua.Template = "physics.get_gravity()"
            </summary>
        </member>
        <member name="M:Physics.set_hflip(System.String,System.Boolean)">
            <summary>
            Flips the collision shapes horizontally for a collision object
            
            @CSharpLua.Template = "physics.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_hflip(types.Hash,System.Boolean)">
            <summary>
            Flips the collision shapes horizontally for a collision object
            
            @CSharpLua.Template = "physics.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_hflip(types.Url,System.Boolean)">
            <summary>
            Flips the collision shapes horizontally for a collision object
            
            @CSharpLua.Template = "physics.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_vflip(System.String,System.Boolean)">
            <summary>
            Flips the collision shapes vertically for a collision object
            
            @CSharpLua.Template = "physics.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_vflip(types.Hash,System.Boolean)">
            <summary>
            Flips the collision shapes vertically for a collision object
            
            @CSharpLua.Template = "physics.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_vflip(types.Url,System.Boolean)">
            <summary>
            Flips the collision shapes vertically for a collision object
            
            @CSharpLua.Template = "physics.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.wakeup(System.String)">
            <summary>
            Collision objects tend to fall asleep when inactive for a small period of time for
            efficiency reasons. This function wakes them up.
            
            @CSharpLua.Template = "physics.wakeup({0})"
            </summary>
        </member>
        <member name="M:Physics.wakeup(types.Hash)">
            <summary>
            Collision objects tend to fall asleep when inactive for a small period of time for
            efficiency reasons. This function wakes them up.
            
            @CSharpLua.Template = "physics.wakeup({0})"
            </summary>
        </member>
        <member name="M:Physics.wakeup(types.Url)">
            <summary>
            Collision objects tend to fall asleep when inactive for a small period of time for
            efficiency reasons. This function wakes them up.
            
            @CSharpLua.Template = "physics.wakeup({0})"
            </summary>
        </member>
        <member name="M:Physics.set_group(System.String,System.String)">
            <summary>
            Updates the group property of a collision object to the specified
            string value. The group name should exist i.e. have been used in
            a collision object in the editor.
            
            @CSharpLua.Template = "physics.set_group({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_group(types.Hash,System.String)">
            <summary>
            Updates the group property of a collision object to the specified
            string value. The group name should exist i.e. have been used in
            a collision object in the editor.
            
            @CSharpLua.Template = "physics.set_group({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.set_group(types.Url,System.String)">
            <summary>
            Updates the group property of a collision object to the specified
            string value. The group name should exist i.e. have been used in
            a collision object in the editor.
            
            @CSharpLua.Template = "physics.set_group({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_group(System.String)">
            <summary>
            Returns the group name of a collision object as a hash.
            
            @CSharpLua.Template = "physics.get_group({0})"
            </summary>
        </member>
        <member name="M:Physics.get_group(types.Hash)">
            <summary>
            Returns the group name of a collision object as a hash.
            
            @CSharpLua.Template = "physics.get_group({0})"
            </summary>
        </member>
        <member name="M:Physics.get_group(types.Url)">
            <summary>
            Returns the group name of a collision object as a hash.
            
            @CSharpLua.Template = "physics.get_group({0})"
            </summary>
        </member>
        <member name="M:Physics.set_maskbit(System.String,System.String,System.Boolean)">
            <summary>
            Sets or clears the masking of a group (maskbit) in a collision object.
            
            @CSharpLua.Template = "physics.set_maskbit({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_maskbit(types.Hash,System.String,System.Boolean)">
            <summary>
            Sets or clears the masking of a group (maskbit) in a collision object.
            
            @CSharpLua.Template = "physics.set_maskbit({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.set_maskbit(types.Url,System.String,System.Boolean)">
            <summary>
            Sets or clears the masking of a group (maskbit) in a collision object.
            
            @CSharpLua.Template = "physics.set_maskbit({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Physics.get_maskbit(System.String,System.String)">
            <summary>
            Returns true if the specified group is set in the mask of a collision
            object, false otherwise.
            
            @CSharpLua.Template = "physics.get_maskbit({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_maskbit(types.Hash,System.String)">
            <summary>
            Returns true if the specified group is set in the mask of a collision
            object, false otherwise.
            
            @CSharpLua.Template = "physics.get_maskbit({0}, {1})"
            </summary>
        </member>
        <member name="M:Physics.get_maskbit(types.Url,System.String)">
            <summary>
            Returns true if the specified group is set in the mask of a collision
            object, false otherwise.
            
            @CSharpLua.Template = "physics.get_maskbit({0}, {1})"
            </summary>
        </member>
        <member name="T:Profiler">
            <summary>
            Profiler API documentation
            
            </summary>
        </member>
        <member name="M:Profiler.get_memory_usage">
            <summary>
            Get the amount of memory used (resident/working set) by the application in bytes, as reported by the OS.
            <span class="icon-attention"></span> This function is not available on <span class="icon-html5"></span> HTML5.
            The values are gathered from internal OS functions which correspond to the following;
            <table>
            <thead>
            <tr>
            <th>OS</th>
            <th>Value</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td><span class="icon-ios"></span> iOS<br/><span class="icon-macos"></span> MacOS<br/><span class="icon-android"></span><br/>Androd<br/><span class="icon-linux"></span> Linux</td>
            <td><a href="https://en.wikipedia.org/wiki/Resident_set_size">Resident memory</a></td>
            </tr>
            <tr>
            <td><span class="icon-windows"></span> Windows</td>
            <td><a href="https://en.wikipedia.org/wiki/Working_set">Working set</a></td>
            </tr>
            <tr>
            <td><span class="icon-html5"></span> HTML5</td>
            <td><span class="icon-attention"></span> Not available</td>
            </tr>
            </tbody>
            </table>
            
            @CSharpLua.Template = "profiler.get_memory_usage()"
            </summary>
        </member>
        <member name="M:Profiler.get_cpu_usage">
            <summary>
            Get the percent of CPU usage by the application, as reported by the OS.
            <span class="icon-attention"></span> This function is not available on <span class="icon-html5"></span> HTML5.
            For some platforms (<span class="icon-android"></span> Android, <span class="icon-linux"></span> Linux and <span class="icon-windows"></span> Windows), this information is only available
            by default in the debug version of the engine. It can be enabled in release version as well
            by checking <code>track_cpu</code> under <code>profiler</code> in the <code>game.project</code> file.
            (This means that the engine will sample the CPU usage in intervalls during execution even in release mode.)
            
            @CSharpLua.Template = "profiler.get_cpu_usage()"
            </summary>
        </member>
        <member name="M:Profiler.enable_ui(System.Boolean)">
            <summary>
            Creates and shows or hides and destroys the on-sceen profiler ui
            The profiler is a real-time tool that shows the numbers of milliseconds spent
            in each scope per frame as well as counters. The profiler is very useful for
            tracking down performance and resource problems.
            
            @CSharpLua.Template = "profiler.enable_ui({0})"
            </summary>
        </member>
        <member name="M:Profiler.set_ui_mode(types.ProfilerMode)">
            <summary>
            Set the on-screen profile mode - run, pause, record or show peak frame
            
            @CSharpLua.Template = "profiler.set_ui_mode({0})"
            </summary>
        </member>
        <member name="M:Profiler.set_ui_view_mode(types.ProfilerViewMode)">
            <summary>
            Set the on-screen profile view mode - minimized or expanded
            
            @CSharpLua.Template = "profiler.set_ui_view_mode({0})"
            </summary>
        </member>
        <member name="M:Profiler.set_ui_vsync_wait_visible(System.Boolean)">
            <summary>
            Shows or hides the time the engine waits for vsync in the on-screen profiler
            Each frame the engine waits for vsync and depending on your vsync settings and how much time
            your game logic takes this time can dwarf the time in the game logic making it hard to
            see details in the on-screen profiler graph and lists.
            Also, by hiding this the FPS times in the header show the time spent each time excuding the
            time spent waiting for vsync. This shows you how long time your game is spending actively
            working each frame.
            This setting also effects the display of recorded frames but does not affect the actual
            recorded frames so it is possible to toggle this on and off when viewing recorded frames.
            By default the vsync wait times is displayed in the profiler.
            
            @CSharpLua.Template = "profiler.set_ui_vsync_wait_visible({0})"
            </summary>
        </member>
        <member name="M:Profiler.recorded_frame_count">
            <summary>
            Get the number of recorded frames in the on-screen profiler ui recording buffer
            
            @CSharpLua.Template = "profiler.recorded_frame_count()"
            </summary>
        </member>
        <member name="M:Profiler.view_recorded_frame(lua.LuaTableBase)">
            <summary>
            Pauses and displays a frame from the recording buffer in the on-screen profiler ui
            The frame to show can either be an absolute frame or a relative frame to the current frame.
            
            @CSharpLua.Template = "profiler.view_recorded_frame({0})"
            </summary>
        </member>
        <member name="M:Profiler.log_text(System.String)">
            <summary>
            Send a text to the profiler
            
            @CSharpLua.Template = "profiler.log_text({0})"
            </summary>
        </member>
        <member name="M:Profiler.scope_begin(System.String)">
            <summary>
            Starts a profile scope.
            
            @CSharpLua.Template = "profiler.scope_begin({0})"
            </summary>
        </member>
        <member name="M:Profiler.scope_end">
            <summary>
            End the current profile scope.
            
            @CSharpLua.Template = "profiler.scope_end()"
            </summary>
        </member>
        <member name="T:Push">
            <summary>
            Push notifications API documentation
            
            </summary>
        </member>
        <member name="T:Render">
            <summary>
            Rendering API documentation
            
            </summary>
        </member>
        <member name="T:Render.draw_debug_text_message">
            <summary>
            </summary>
        </member>
        <member name="T:Render.draw_line_message">
            <summary>
            </summary>
        </member>
        <member name="T:Render.window_resized_message">
            <summary>
            </summary>
        </member>
        <member name="T:Render.resize_message">
            <summary>
            </summary>
        </member>
        <member name="T:Render.clear_color_message">
            <summary>
            </summary>
        </member>
        <member name="M:Render.constant_buffer">
            <summary>
            Constant buffers are used to set shader program variables and are optionally passed to the <code>render.draw()</code> function.
            The buffer's constant elements can be indexed like an ordinary Lua table, but you can't iterate over them with pairs() or ipairs().
            
            @CSharpLua.Template = "render.constant_buffer()"
            </summary>
        </member>
        <member name="M:Render.enable_state(types.RenderState)">
            <summary>
            Enables a particular render state. The state will be enabled until disabled.
            
            @CSharpLua.Template = "render.enable_state({0})"
            </summary>
        </member>
        <member name="M:Render.disable_state(types.RenderState)">
            <summary>
            Disables a render state.
            
            @CSharpLua.Template = "render.disable_state({0})"
            </summary>
        </member>
        <member name="M:Render.set_viewport(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Set the render viewport to the specified rectangle.
            
            @CSharpLua.Template = "render.set_viewport({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Render.disable_texture(System.Double)">
            <summary>
            Disables a texture unit for a render target that has previourly been enabled.
            
            @CSharpLua.Template = "render.disable_texture({0})"
            </summary>
        </member>
        <member name="M:Render.clear(lua.LuaTableBase)">
            <summary>
            Clear buffers in the currently enabled render target with specified value. If the render target has been created with multiple
            color attachments, all buffers will be cleared with the same value.
            
            @CSharpLua.Template = "render.clear({0})"
            </summary>
        </member>
        <member name="M:Render.draw(lua.LuaTableBase)">
            <summary>
            Draws all objects that match a specified predicate. An optional constant buffer can be
            provided to override the default constants. If no constants buffer is provided, a default
            system constants buffer is used containing constants as defined in materials and set through
            <a href="/ref/go#go.set">go.set</a> (or <a href="/ref/particlefx#particlefx.set_constant">particlefx.set_constant</a>) on visual components.
            
            @CSharpLua.Template = "render.draw({0})"
            </summary>
        </member>
        <member name="M:Render.draw(lua.LuaTableBase,lua.LuaTableBase)">
            <summary>
            Draws all objects that match a specified predicate. An optional constant buffer can be
            provided to override the default constants. If no constants buffer is provided, a default
            system constants buffer is used containing constants as defined in materials and set through
            <a href="/ref/go#go.set">go.set</a> (or <a href="/ref/particlefx#particlefx.set_constant">particlefx.set_constant</a>) on visual components.
            
            @CSharpLua.Template = "render.draw({0}, {1})"
            </summary>
        </member>
        <member name="M:Render.draw_debug3d">
            <summary>
            Draws all 3d debug graphics such as lines drawn with "draw_line" messages and physics visualization.
            
            @CSharpLua.Template = "render.draw_debug3d()"
            </summary>
        </member>
        <member name="M:Render.draw_debug3d(lua.LuaTableBase)">
            <summary>
            Draws all 3d debug graphics such as lines drawn with "draw_line" messages and physics visualization.
            
            @CSharpLua.Template = "render.draw_debug3d({0})"
            </summary>
        </member>
        <member name="M:Render.set_view(types.Matrix4)">
            <summary>
            Sets the view matrix to use when rendering.
            
            @CSharpLua.Template = "render.set_view({0})"
            </summary>
        </member>
        <member name="M:Render.set_projection(types.Matrix4)">
            <summary>
            Sets the projection matrix to use when rendering.
            
            @CSharpLua.Template = "render.set_projection({0})"
            </summary>
        </member>
        <member name="M:Render.set_blend_func(types.BlendFunction,types.BlendFunction)">
            <summary>
            Specifies the arithmetic used when computing pixel values that are written to the frame
            buffer. In RGBA mode, pixels can be drawn using a function that blends the source RGBA
            pixel values with the destination pixel values already in the frame buffer.
            Blending is initially disabled.
            <code>source_factor</code> specifies which method is used to scale the source color components.
            <code>destination_factor</code> specifies which method is used to scale the destination color
            components.
            Source color components are referred to as (R<sub>s</sub>,G<sub>s</sub>,B<sub>s</sub>,A<sub>s</sub>).
            Destination color components are referred to as (R<sub>d</sub>,G<sub>d</sub>,B<sub>d</sub>,A<sub>d</sub>).
            The color specified by setting the blendcolor is referred to as (R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub>,A<sub>c</sub>).
            The source scale factor is referred to as (s<sub>R</sub>,s<sub>G</sub>,s<sub>B</sub>,s<sub>A</sub>).
            The destination scale factor is referred to as (d<sub>R</sub>,d<sub>G</sub>,d<sub>B</sub>,d<sub>A</sub>).
            The color values have integer values between 0 and (k<sub>R</sub>,k<sub>G</sub>,k<sub>B</sub>,k<sub>A</sub>), where k<sub>c</sub> = 2<sup>m<sub>c</sub></sup> - 1 and m<sub>c</sub> is the number of bitplanes for that color. I.e for 8 bit color depth, color values are between <code>0</code> and <code>255</code>.
            Available factor constants and corresponding scale factors:
            <table>
            <thead>
            <tr>
            <th>Factor constant</th>
            <th>Scale factor (f<sub>R</sub>,f<sub>G</sub>,f<sub>B</sub>,f<sub>A</sub>)</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td><code>render.BLEND_ZERO</code></td>
            <td>(0,0,0,0)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE</code></td>
            <td>(1,1,1,1)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_SRC_COLOR</code></td>
            <td>(R<sub>s</sub>/k<sub>R</sub>,G<sub>s</sub>/k<sub>G</sub>,B<sub>s</sub>/k<sub>B</sub>,A<sub>s</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_SRC_COLOR</code></td>
            <td>(1,1,1,1) - (R<sub>s</sub>/k<sub>R</sub>,G<sub>s</sub>/k<sub>G</sub>,B<sub>s</sub>/k<sub>B</sub>,A<sub>s</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_DST_COLOR</code></td>
            <td>(R<sub>d</sub>/k<sub>R</sub>,G<sub>d</sub>/k<sub>G</sub>,B<sub>d</sub>/k<sub>B</sub>,A<sub>d</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_DST_COLOR</code></td>
            <td>(1,1,1,1) - (R<sub>d</sub>/k<sub>R</sub>,G<sub>d</sub>/k<sub>G</sub>,B<sub>d</sub>/k<sub>B</sub>,A<sub>d</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_SRC_ALPHA</code></td>
            <td>(A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_SRC_ALPHA</code></td>
            <td>(1,1,1,1) - (A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>,A<sub>s</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_DST_ALPHA</code></td>
            <td>(A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_DST_ALPHA</code></td>
            <td>(1,1,1,1) - (A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>,A<sub>d</sub>/k<sub>A</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_CONSTANT_COLOR</code></td>
            <td>(R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub>,A<sub>c</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_CONSTANT_COLOR</code></td>
            <td>(1,1,1,1) - (R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub>,A<sub>c</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_CONSTANT_ALPHA</code></td>
            <td>(A<sub>c</sub>,A<sub>c</sub>,A<sub>c</sub>,A<sub>c</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_ONE_MINUS_CONSTANT_ALPHA</code></td>
            <td>(1,1,1,1) - (A<sub>c</sub>,A<sub>c</sub>,A<sub>c</sub>,A<sub>c</sub>)</td>
            </tr>
            <tr>
            <td><code>render.BLEND_SRC_ALPHA_SATURATE</code></td>
            <td>(i,i,i,1) where i = min(A<sub>s</sub>, k<sub>A</sub> - A<sub>d</sub>) /k<sub>A</sub></td>
            </tr>
            </tbody>
            </table>
            The blended RGBA values of a pixel comes from the following equations:
            <ul>
            <li>R<sub>d</sub> = min(k<sub>R</sub>, R<sub>s</sub> * s<sub>R</sub> + R<sub>d</sub> * d<sub>R</sub>)</li>
            <li>G<sub>d</sub> = min(k<sub>G</sub>, G<sub>s</sub> * s<sub>G</sub> + G<sub>d</sub> * d<sub>G</sub>)</li>
            <li>B<sub>d</sub> = min(k<sub>B</sub>, B<sub>s</sub> * s<sub>B</sub> + B<sub>d</sub> * d<sub>B</sub>)</li>
            <li>A<sub>d</sub> = min(k<sub>A</sub>, A<sub>s</sub> * s<sub>A</sub> + A<sub>d</sub> * d<sub>A</sub>)</li>
            </ul>
            Blend function <code>(render.BLEND_SRC_ALPHA, render.BLEND_ONE_MINUS_SRC_ALPHA)</code> is useful for
            drawing with transparency when the drawn objects are sorted from farthest to nearest.
            It is also useful for drawing antialiased points and lines in arbitrary order.
            
            @CSharpLua.Template = "render.set_blend_func({0}, {1})"
            </summary>
        </member>
        <member name="M:Render.set_color_mask(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Specifies whether the individual color components in the frame buffer is enabled for writing (<code>true</code>) or disabled (<code>false</code>). For example, if <code>blue</code> is <code>false</code>, nothing is written to the blue component of any pixel in any of the color buffers, regardless of the drawing operation attempted. Note that writing are either enabled or disabled for entire color components, not the individual bits of a component.
            The component masks are all initially <code>true</code>.
            
            @CSharpLua.Template = "render.set_color_mask({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Render.set_depth_mask(System.Boolean)">
            <summary>
            Specifies whether the depth buffer is enabled for writing. The supplied mask governs
            if depth buffer writing is enabled (<code>true</code>) or disabled (<code>false</code>).
            The mask is initially <code>true</code>.
            
            @CSharpLua.Template = "render.set_depth_mask({0})"
            </summary>
        </member>
        <member name="M:Render.set_stencil_mask(System.Double)">
            <summary>
            The stencil mask controls the writing of individual bits in the stencil buffer.
            The least significant <code>n</code> bits of the parameter <code>mask</code>, where <code>n</code> is the number of
            bits in the stencil buffer, specify the mask.
            Where a <code>1</code> bit appears in the mask, the corresponding
            bit in the stencil buffer can be written. Where a <code>0</code> bit appears in the mask,
            the corresponding bit in the stencil buffer is never written.
            The mask is initially all <code>1</code>'s.
            
            @CSharpLua.Template = "render.set_stencil_mask({0})"
            </summary>
        </member>
        <member name="M:Render.set_depth_func(types.DepthFunction)">
            <summary>
            Specifies the function that should be used to compare each incoming pixel
            depth value with the value present in the depth buffer.
            The comparison is performed only if depth testing is enabled and specifies
            the conditions under which a pixel will be drawn.
            Function constants:
            <ul>
            <li><code>render.COMPARE_FUNC_NEVER</code> (never passes)</li>
            <li><code>render.COMPARE_FUNC_LESS</code> (passes if the incoming depth value is less than the stored value)</li>
            <li><code>render.COMPARE_FUNC_LEQUAL</code> (passes if the incoming depth value is less than or equal to the stored value)</li>
            <li><code>render.COMPARE_FUNC_GREATER</code> (passes if the incoming depth value is greater than the stored value)</li>
            <li><code>render.COMPARE_FUNC_GEQUAL</code> (passes if the incoming depth value is greater than or equal to the stored value)</li>
            <li><code>render.COMPARE_FUNC_EQUAL</code> (passes if the incoming depth value is equal to the stored value)</li>
            <li><code>render.COMPARE_FUNC_NOTEQUAL</code> (passes if the incoming depth value is not equal to the stored value)</li>
            <li><code>render.COMPARE_FUNC_ALWAYS</code> (always passes)</li>
            </ul>
            The depth function is initially set to <code>render.COMPARE_FUNC_LESS</code>.
            
            @CSharpLua.Template = "render.set_depth_func({0})"
            </summary>
        </member>
        <member name="M:Render.set_stencil_func(types.DepthFunction,System.Double,System.Double)">
            <summary>
            Stenciling is similar to depth-buffering as it enables and disables drawing on a
            per-pixel basis. First, GL drawing primitives are drawn into the stencil planes.
            Second, geometry and images are rendered but using the stencil planes to mask out
            where to draw.
            The stencil test discards a pixel based on the outcome of a comparison between the
            reference value <code>ref</code> and the corresponding value in the stencil buffer.
            <code>func</code> specifies the comparison function. See the table below for values.
            The initial value is <code>render.COMPARE_FUNC_ALWAYS</code>.
            <code>ref</code> specifies the reference value for the stencil test. The value is clamped to
            the range [0, 2<sup>n</sup>-1], where n is the number of bitplanes in the stencil buffer.
            The initial value is <code>0</code>.
            <code>mask</code> is ANDed with both the reference value and the stored stencil value when the test
            is done. The initial value is all <code>1</code>'s.
            Function constant:
            <ul>
            <li><code>render.COMPARE_FUNC_NEVER</code> (never passes)</li>
            <li><code>render.COMPARE_FUNC_LESS</code> (passes if (ref &amp; mask) &lt; (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_LEQUAL</code> (passes if (ref &amp; mask) &lt;= (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_GREATER</code> (passes if (ref &amp; mask) &gt; (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_GEQUAL</code> (passes if (ref &amp; mask) &gt;= (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_EQUAL</code> (passes if (ref &amp; mask) = (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_NOTEQUAL</code> (passes if (ref &amp; mask) != (stencil &amp; mask))</li>
            <li><code>render.COMPARE_FUNC_ALWAYS</code> (always passes)</li>
            </ul>
            
            @CSharpLua.Template = "render.set_stencil_func({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Render.set_stencil_op(types.StencilOperator,types.StencilOperator,types.StencilOperator)">
            <summary>
            The stencil test discards a pixel based on the outcome of a comparison between the
            reference value <code>ref</code> and the corresponding value in the stencil buffer.
            To control the test, call <a href="/ref/render#render.set_stencil_func">render.set_stencil_func</a>.
            This function takes three arguments that control what happens to the stored stencil
            value while stenciling is enabled. If the stencil test fails, no change is made to the
            pixel's color or depth buffers, and <code>sfail</code> specifies what happens to the stencil buffer
            contents.
            Operator constants:
            <ul>
            <li><code>render.STENCIL_OP_KEEP</code> (keeps the current value)</li>
            <li><code>render.STENCIL_OP_ZERO</code> (sets the stencil buffer value to 0)</li>
            <li><code>render.STENCIL_OP_REPLACE</code> (sets the stencil buffer value to <code>ref</code>, as specified by <a href="/ref/render#render.set_stencil_func">render.set_stencil_func</a>)</li>
            <li><code>render.STENCIL_OP_INCR</code> (increments the stencil buffer value and clamp to the maximum representable unsigned value)</li>
            <li><code>render.STENCIL_OP_INCR_WRAP</code> (increments the stencil buffer value and wrap to zero when incrementing the maximum representable unsigned value)</li>
            <li><code>render.STENCIL_OP_DECR</code> (decrements the current stencil buffer value and clamp to 0)</li>
            <li><code>render.STENCIL_OP_DECR_WRAP</code> (decrements the current stencil buffer value and wrap to the maximum representable unsigned value when decrementing zero)</li>
            <li><code>render.STENCIL_OP_INVERT</code> (bitwise inverts the current stencil buffer value)</li>
            </ul>
            <code>dppass</code> and <code>dpfail</code> specify the stencil buffer actions depending on whether subsequent
            depth buffer tests succeed (dppass) or fail (dpfail).
            The initial value for all operators is <code>render.STENCIL_OP_KEEP</code>.
            
            @CSharpLua.Template = "render.set_stencil_op({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Render.set_cull_face(types.FaceType)">
            <summary>
            Specifies whether front- or back-facing polygons can be culled
            when polygon culling is enabled. Polygon culling is initially disabled.
            If mode is <code>render.FACE_FRONT_AND_BACK</code>, no polygons are drawn, but other
            primitives such as points and lines are drawn. The initial value for
            <code>face_type</code> is <code>render.FACE_BACK</code>.
            
            @CSharpLua.Template = "render.set_cull_face({0})"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Render.set_polygon_offset(System.Double,System.Double)" -->
        <member name="M:Render.get_width">
            <summary>
            Returns the logical window width that is set in the "game.project" settings.
            Note that the actual window pixel size can change, either by device constraints
            or user input.
            
            @CSharpLua.Template = "render.get_width()"
            </summary>
        </member>
        <member name="M:Render.get_height">
            <summary>
            Returns the logical window height that is set in the "game.project" settings.
            Note that the actual window pixel size can change, either by device constraints
            or user input.
            
            @CSharpLua.Template = "render.get_height()"
            </summary>
        </member>
        <member name="M:Render.get_window_width">
            <summary>
            Returns the actual physical window width.
            Note that this value might differ from the logical width that is set in the
            "game.project" settings.
            
            @CSharpLua.Template = "render.get_window_width()"
            </summary>
        </member>
        <member name="M:Render.get_window_height">
            <summary>
            Returns the actual physical window height.
            Note that this value might differ from the logical height that is set in the
            "game.project" settings.
            
            @CSharpLua.Template = "render.get_window_height()"
            </summary>
        </member>
        <member name="M:Render.predicate(lua.LuaTableBase)">
            <summary>
            This function returns a new render predicate for objects with materials matching
            the provided material tags. The provided tags are combined into a bit mask
            for the predicate. If multiple tags are provided, the predicate matches materials
            with all tags ANDed together.
            The current limit to the number of tags that can be defined is <code>64</code>.
            
            @CSharpLua.Template = "render.predicate({0})"
            </summary>
        </member>
        <member name="M:Render.predicate(lua.LuaArrayOf{System.String})">
            <summary>
            This function returns a new render predicate for objects with materials matching
            the provided material tags. The provided tags are combined into a bit mask
            for the predicate. If multiple tags are provided, the predicate matches materials
            with all tags ANDed together.
            The current limit to the number of tags that can be defined is <code>64</code>.
            
            @CSharpLua.Template = "render.predicate({0})"
            </summary>
        </member>
        <member name="M:Render.enable_material(System.String)">
            <summary>
            If another material was already enabled, it will be automatically disabled
            and the specified material is used instead.
            The name of the material must be specified in the ".render" resource set
            in the "game.project" setting.
            
            @CSharpLua.Template = "render.enable_material({0})"
            </summary>
        </member>
        <member name="M:Render.enable_material(types.Hash)">
            <summary>
            If another material was already enabled, it will be automatically disabled
            and the specified material is used instead.
            The name of the material must be specified in the ".render" resource set
            in the "game.project" setting.
            
            @CSharpLua.Template = "render.enable_material({0})"
            </summary>
        </member>
        <member name="M:Render.disable_material">
            <summary>
            If a material is currently enabled, disable it.
            The name of the material must be specified in the ".render" resource set
            in the "game.project" setting.
            
            @CSharpLua.Template = "render.disable_material()"
            </summary>
        </member>
        <member name="T:Resource">
            <summary>
            Resource API documentation
            
            </summary>
        </member>
        <member name="M:Resource.material">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.material()"
            </summary>
        </member>
        <member name="M:Resource.material(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.material({0})"
            </summary>
        </member>
        <member name="M:Resource.font">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.font()"
            </summary>
        </member>
        <member name="M:Resource.font(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.font({0})"
            </summary>
        </member>
        <member name="M:Resource.texture">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.texture()"
            </summary>
        </member>
        <member name="M:Resource.texture(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.texture({0})"
            </summary>
        </member>
        <member name="M:Resource.atlas">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.atlas()"
            </summary>
        </member>
        <member name="M:Resource.atlas(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.atlas({0})"
            </summary>
        </member>
        <member name="M:Resource.buffer">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.buffer()"
            </summary>
        </member>
        <member name="M:Resource.buffer(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.buffer({0})"
            </summary>
        </member>
        <member name="M:Resource.tile_source">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.tile_source()"
            </summary>
        </member>
        <member name="M:Resource.tile_source(System.String)">
            <summary>
            Constructor-like function with two purposes:
            <ul>
            <li>Load the specified resource as part of loading the script</li>
            <li>Return a hash to the run-time version of the resource</li>
            </ul>
            <span class="icon-attention"></span> This function can only be called within <a href="/ref/go#go.property">go.property</a> function calls.
            
            @CSharpLua.Template = "resource.tile_source({0})"
            </summary>
        </member>
        <member name="M:Resource.set(System.String,types.DataBuffer)">
            <summary>
            Sets the resource data for a specific resource
            
            @CSharpLua.Template = "resource.set({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.set(types.Hash,types.DataBuffer)">
            <summary>
            Sets the resource data for a specific resource
            
            @CSharpLua.Template = "resource.set({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.load(System.String)">
            <summary>
            Loads the resource data for a specific resource.
            
            @CSharpLua.Template = "resource.load({0})"
            </summary>
        </member>
        <member name="M:Resource.set_texture(types.Hash,lua.LuaTableBase,types.DataBuffer)">
            <summary>
            Sets the pixel data for a specific texture.
            
            @CSharpLua.Template = "resource.set_texture({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Resource.set_texture(System.String,lua.LuaTableBase,types.DataBuffer)">
            <summary>
            Sets the pixel data for a specific texture.
            
            @CSharpLua.Template = "resource.set_texture({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Resource.set_sound(types.Hash,System.String)">
            <summary>
            Update internal sound resource (wavc/oggc) with new data
            
            @CSharpLua.Template = "resource.set_sound({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.set_sound(System.String,System.String)">
            <summary>
            Update internal sound resource (wavc/oggc) with new data
            
            @CSharpLua.Template = "resource.set_sound({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.get_buffer(types.Hash)">
            <summary>
            gets the buffer from a resource
            
            @CSharpLua.Template = "resource.get_buffer({0})"
            </summary>
        </member>
        <member name="M:Resource.get_buffer(System.String)">
            <summary>
            gets the buffer from a resource
            
            @CSharpLua.Template = "resource.get_buffer({0})"
            </summary>
        </member>
        <member name="M:Resource.set_buffer(types.Hash,types.DataBuffer)">
            <summary>
            sets the buffer of a resource
            
            @CSharpLua.Template = "resource.set_buffer({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.set_buffer(System.String,types.DataBuffer)">
            <summary>
            sets the buffer of a resource
            
            @CSharpLua.Template = "resource.set_buffer({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.get_text_metrics(types.Hash,System.String)">
            <summary>
            Gets the text metrics from a font
            
            @CSharpLua.Template = "resource.get_text_metrics({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.get_text_metrics(types.Hash,System.String,lua.LuaTableBase)">
            <summary>
            Gets the text metrics from a font
            
            @CSharpLua.Template = "resource.get_text_metrics({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Resource.get_current_manifest">
            <summary>
            Return a reference to the Manifest that is currently loaded.
            
            @CSharpLua.Template = "resource.get_current_manifest()"
            </summary>
        </member>
        <member name="M:Resource.store_resource(System.Double,System.String,System.String,System.Action{System.Object,System.String,System.Boolean})">
            <summary>
            add a resource to the data archive and runtime index. The resource will be verified
            internally before being added to the data archive.
            
            @CSharpLua.Template = "resource.store_resource({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Resource.store_manifest(System.String,System.Action{System.Object,types.ResourceLiveUpdate})">
            <summary>
            Create a new manifest from a buffer. The created manifest is verified
            by ensuring that the manifest was signed using the bundled public/private
            key-pair during the bundle process and that the manifest supports the current
            running engine version. Once the manifest is verified it is stored on device.
            The next time the engine starts (or is rebooted) it will look for the stored
            manifest before loading resources. Storing a new manifest allows the
            developer to update the game, modify existing resources, or add new
            resources to the game through LiveUpdate.
            
            @CSharpLua.Template = "resource.store_manifest({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.store_archive(System.String,System.Action{System.Object,types.ResourceLiveUpdate})">
            <summary>
            Stores a zip file and uses it for live update content. The contents of the
            zip file will be verified against the manifest to ensure file integrity.
            It is possible to opt out of the resource verification using an option passed
            to this function.
            The path is stored in the (internal) live update location.
            
            @CSharpLua.Template = "resource.store_archive({0}, {1})"
            </summary>
        </member>
        <member name="M:Resource.store_archive(System.String,System.Action{System.Object,types.ResourceLiveUpdate},lua.LuaTableBase)">
            <summary>
            Stores a zip file and uses it for live update content. The contents of the
            zip file will be verified against the manifest to ensure file integrity.
            It is possible to opt out of the resource verification using an option passed
            to this function.
            The path is stored in the (internal) live update location.
            
            @CSharpLua.Template = "resource.store_archive({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Resource.is_using_liveupdate_data">
            <summary>
            Is any liveupdate data mounted and currently in use?
            This can be used to determine if a new manifest or zip file should be downloaded.
            
            @CSharpLua.Template = "resource.is_using_liveupdate_data()"
            </summary>
        </member>
        <member name="T:Sound">
            <summary>
            Sound API documentation
            
            </summary>
        </member>
        <member name="T:Sound.play_sound_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sound.stop_sound_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sound.set_gain_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sound.sound_done_message">
            <summary>
            </summary>
        </member>
        <member name="M:Sound.is_music_playing">
            <summary>
            Checks if background music is playing, e.g. from iTunes.
            <span class="icon-macos"></span><span class="icon-windows"></span><span class="icon-linux"></span><span class="icon-html5"></span> On non mobile platforms,
            this function always return <code>false</code>.
            <span class="icon-attention"></span><span class="icon-android"></span> On Android you can only get a correct reading
            of this state if your game is not playing any sounds itself. This is a limitation
            in the Android SDK. If your game is playing any sounds, <em>even with a gain of zero</em>, this
            function will return <code>false</code>.
            The best time to call this function is:
            <ul>
            <li>In the <code>init</code> function of your main collection script before any sounds are triggered</li>
            <li>In a window listener callback when the window.WINDOW_EVENT_FOCUS_GAINED event is received</li>
            </ul>
            Both those times will give you a correct reading of the state even when your application is
            swapped out and in while playing sounds and it works equally well on Android and iOS.
            
            @CSharpLua.Template = "sound.is_music_playing()"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sound.get_rms(System.String,System.Double,System.Double@)" -->
        <!-- Badly formed XML comment ignored for member "M:Sound.get_rms(types.Hash,System.Double,System.Double@)" -->
        <member name="M:Sound.get_peak(System.String,System.Double,System.Double@)">
            <summary>
            Get peak value from mixer group.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            Also note that the returned value might be an approximation and in particular
            the effective window might be larger than specified.
            
            @CSharpLua.Template = "sound.get_peak({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.get_peak(types.Hash,System.Double,System.Double@)">
            <summary>
            Get peak value from mixer group.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            Also note that the returned value might be an approximation and in particular
            the effective window might be larger than specified.
            
            @CSharpLua.Template = "sound.get_peak({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_group_gain(System.String,System.Double)">
            <summary>
            Set mixer group gain
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_group_gain({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_group_gain(types.Hash,System.Double)">
            <summary>
            Set mixer group gain
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_group_gain({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.get_group_gain(System.String)">
            <summary>
            Get mixer group gain
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.get_group_gain({0})"
            </summary>
        </member>
        <member name="M:Sound.get_group_gain(types.Hash)">
            <summary>
            Get mixer group gain
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.get_group_gain({0})"
            </summary>
        </member>
        <member name="M:Sound.get_groups">
            <summary>
            Get a table of all mixer group names (hashes).
            
            @CSharpLua.Template = "sound.get_groups()"
            </summary>
        </member>
        <member name="M:Sound.get_group_name(System.String)">
            <summary>
            Get a mixer group name as a string.
            <span class="icon-attention"></span> This function is to be used for debugging and
            development tooling only. The function does a reverse hash lookup, which does not
            return a proper string value when the game is built in release mode.
            
            @CSharpLua.Template = "sound.get_group_name({0})"
            </summary>
        </member>
        <member name="M:Sound.get_group_name(types.Hash)">
            <summary>
            Get a mixer group name as a string.
            <span class="icon-attention"></span> This function is to be used for debugging and
            development tooling only. The function does a reverse hash lookup, which does not
            return a proper string value when the game is built in release mode.
            
            @CSharpLua.Template = "sound.get_group_name({0})"
            </summary>
        </member>
        <member name="M:Sound.is_phone_call_active">
            <summary>
            Checks if a phone call is active. If there is an active phone call all
            other sounds will be muted until the phone call is finished.
            <span class="icon-macos"></span><span class="icon-windows"></span><span class="icon-linux"></span><span class="icon-html5"></span> On non mobile platforms,
            this function always return <code>false</code>.
            
            @CSharpLua.Template = "sound.is_phone_call_active()"
            </summary>
        </member>
        <member name="M:Sound.play(System.String)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0})"
            </summary>
        </member>
        <member name="M:Sound.play(System.String,lua.LuaTableBase)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.play(System.String,lua.LuaTableBase,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Hash)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Hash,lua.LuaTableBase)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Hash,lua.LuaTableBase,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Url)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Url,lua.LuaTableBase)">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.play(types.Url,lua.LuaTableBase,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Make the sound component play its sound. Multiple voices are supported. The limit is set to 32 voices per sound component.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            <span class="icon-attention"></span> A sound will continue to play even if the game object the sound component belonged to is deleted. You can call <code>sound.stop()</code> to stop the sound.
            
            @CSharpLua.Template = "sound.play({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sound.stop(System.String)">
            <summary>
            Stop playing all active voices
            
            @CSharpLua.Template = "sound.stop({0})"
            </summary>
        </member>
        <member name="M:Sound.stop(types.Hash)">
            <summary>
            Stop playing all active voices
            
            @CSharpLua.Template = "sound.stop({0})"
            </summary>
        </member>
        <member name="M:Sound.stop(types.Url)">
            <summary>
            Stop playing all active voices
            
            @CSharpLua.Template = "sound.stop({0})"
            </summary>
        </member>
        <member name="M:Sound.pause(System.String,System.Boolean)">
            <summary>
            Pause all active voices
            
            @CSharpLua.Template = "sound.pause({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.pause(types.Hash,System.Boolean)">
            <summary>
            Pause all active voices
            
            @CSharpLua.Template = "sound.pause({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.pause(types.Url,System.Boolean)">
            <summary>
            Pause all active voices
            
            @CSharpLua.Template = "sound.pause({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(System.String)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(System.String,System.Double)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(types.Hash)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(types.Hash,System.Double)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(types.Url)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0})"
            </summary>
        </member>
        <member name="M:Sound.set_gain(types.Url,System.Double)">
            <summary>
            Set gain on all active playing voices of a sound.
            <span class="icon-attention"></span> Note that gain is in linear scale, between 0 and 1.
            To get the dB value from the gain, use the formula <code>20 * log(gain)</code>.
            Inversely, to find the linear value from a dB value, use the formula
            <code>10<sup>db/20</sup></code>.
            
            @CSharpLua.Template = "sound.set_gain({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(System.String)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(System.String,System.Double)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(types.Hash)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(types.Hash,System.Double)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0}, {1})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(types.Url)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0})"
            </summary>
        </member>
        <member name="M:Sound.set_pan(types.Url,System.Double)">
            <summary>
            Set panning on all active playing voices of a sound.
            The valid range is from -1.0 to 1.0, representing -45 degrees left, to +45 degrees right.
            
            @CSharpLua.Template = "sound.set_pan({0}, {1})"
            </summary>
        </member>
        <member name="T:Sprite">
            <summary>
            Sprite API documentation
            
            </summary>
        </member>
        <member name="T:Sprite.play_animation_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sprite.animation_done_message">
            <summary>
            </summary>
        </member>
        <member name="M:Sprite.set_hflip(System.String,System.Boolean)">
            <summary>
            Sets horizontal flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.set_hflip(types.Hash,System.Boolean)">
            <summary>
            Sets horizontal flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.set_hflip(types.Url,System.Boolean)">
            <summary>
            Sets horizontal flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_hflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.set_vflip(System.String,System.Boolean)">
            <summary>
            Sets vertical flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.set_vflip(types.Hash,System.Boolean)">
            <summary>
            Sets vertical flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.set_vflip(types.Url,System.Boolean)">
            <summary>
            Sets vertical flipping of the provided sprite's animations.
            The sprite is identified by its URL.
            If the currently playing animation is flipped by default, flipping it again will make it appear like the original texture.
            
            @CSharpLua.Template = "sprite.set_vflip({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(System.String,types.Hash)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(System.String,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(System.String,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url},lua.LuaTableBase)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Hash,types.Hash)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Hash,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Hash,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url},lua.LuaTableBase)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Url,types.Hash)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Url,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url})">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Sprite.play_flipbook(types.Url,types.Hash,System.Action{System.Object,types.Hash,lua.LuaTable,types.Url},lua.LuaTableBase)">
            <summary>
            Play an animation on a sprite component from its tile set
            An optional completion callback function can be provided that will be called when
            the animation has completed playing. If no function is provided,
            a <a href="#animation_done">animation_done</a> message is sent to the script that started the animation.
            
            @CSharpLua.Template = "sprite.play_flipbook({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="T:support.Component">
            <summary>
            Generic access for both builtin components and user components.
            </summary>
        </member>
        <member name="M:support.Component.AtUser``1(support.Locator)">
            <summary>
            Specialized variant that will handle a USERCOMPONENT only.  But exists as an unsafe private that supposedly
            allows any component.  However, it really only supports IUserComponent.
            </summary>
            <param name="locator"></param>
            <typeparam name="TComponent"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:support.Component.AtBuiltIn``1(support.Locator)">
            <summary>
            Specialized variant that will handle a USERCOMPONENT only.  But exists as an unsafe private that supposedly
            allows any component.  However, it really only supports IBuiltInComponent.
            </summary>
            <param name="locator"></param>
            <typeparam name="TComponent"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:support.ComponentLocator.#ctor(System.String)">
            <summary>
                Resolves the component relative to the current game object.
            </summary>
            <param name="componentName"></param>
        </member>
        <member name="M:support.ComponentLocator.#ctor(System.String,System.String)">
            <summary>
                Resolves the component relative to the specified game object
            </summary>
            <param name="gameobjectPath"></param>
            <param name="componentName"></param>
        </member>
        <member name="M:support.GameObjectReference.Component``1(types.Hash)">
            <summary>
            A convenience shortcut for Component.At that handles fetching the Component relative
            to this gameobject.
            </summary>
            <param name="hash"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:support.GameObjectScript`1">
            <summary>
                Base class for all game object scripts (.script).
            </summary>
        </member>
        <member name="M:support.GameObjectScript`1.init">
            <summary>
                Called when a script component is initialized.
                This is a callback-function, which is called by the engine when a script component is initialized. It can be used
                to set the initial state of the script.
            </summary>
        </member>
        <member name="M:support.GameObjectScript`1.final">
            <summary>
                Called when a script component is finalized.
                This is a callback-function, which is called by the engine when a script component is finalized (destroyed). It can
                be used to e.g. take some last action, report the finalization to other game object instances, delete spawned
                objects
                or release user input focus (see `release_input_focus`).
            </summary>
        </member>
        <member name="M:support.GameObjectScript`1.update(System.Single)">
            <summary>
                Called every frame to update the script component.
                This is a callback-function, which is called by the engine every frame to update the state of a script component.
                It can be used to perform any kind of game related tasks, e.g. moving the game object instance.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.GameObjectScript`1.fixed_update(System.Single)">
            <summary>
                Called every frame to update the script component.
                Frame-rate independent update. dt contains the delta time since the last update.
                Useful when you wish to manipulate physics objects at regular intervals to achieve a stable physics simulation.
                Requires that `physics.use_fixed_timestep` is enabled in game.project.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.GameObjectScript`1.on_message(types.Hash,System.Object,types.Hash)">
            <summary>
                Called when a message has been sent to the script component.
                This is a callback-function, which is called by the engine whenever a message has been sent to the script
                component.
                It can be used to take action on the message, e.g. send a response back to the sender of the message.
                The `message` parameter is a table containing the message data. If the message is sent from the engine, the
                documentation of the message specifies which data is supplied.
            </summary>
            <param name="message_id">id of the received message</param>
            <param name="message">a table containing the message data</param>
            <param name="sender">address of the sender</param>
        </member>
        <member name="M:support.GameObjectScript`1.on_input(types.Hash,System.Object)">
            <summary>
                Called when user input is received.
                This is a callback-function, which is called by the engine when user input is sent to the game object instance of
                the script.
                It can be used to take action on the input, e.g. move the instance according to the input.
                For an instance to obtain user input, it must first acquire input focuse through the message `acquire_input_focus`.
                See the documentation of that message for more information.
                The `action` parameter is a table containing data about the input mapped to the `action_id`.
                For mapped actions it specifies the value of the input and if it was just pressed or released.
                Actions are mapped to input in an input_binding-file.
                Mouse movement is specifically handled and uses `nil` as its `action_id`.
                The `action` only contains positional parameters in this case, such as x and y of the pointer.
            </summary>
            <param name="action_id">id of the received input action, as mapped in the input_binding-file</param>
            <param name="action">a table containing the input data, see above for a description</param>
            <returns>boolean to signal if the input should be consumed (not passed on to others) or not, default is false</returns>
        </member>
        <member name="M:support.GameObjectScript`1.on_reload">
            <summary>
                Called when the script component is reloaded.
                This is a callback-function, which is called by the engine when the script component is reloaded, e.g. from the
                editor.
                It can be used for live development, e.g. to tweak constants or set up the state properly for the instance.
            </summary>
        </member>
        <member name="T:support.GUIScript`1">
            <summary>
                Base class for all game object scripts (.gui_script). Run by GUI components and usually containing the logic required to display GUI elements like heads up displays, menus etc. GUI scripts have access to the GUI library functions.
            </summary>
        </member>
        <member name="M:support.GUIScript`1.init">
            <summary>
                Called when a script component is initialized.
                This is a callback-function, which is called by the engine when a script component is initialized. It can be used
                to set the initial state of the script.
            </summary>
        </member>
        <member name="M:support.GUIScript`1.final">
            <summary>
                Called when a script component is finalized.
                This is a callback-function, which is called by the engine when a script component is finalized (destroyed). It can
                be used to e.g. take some last action, report the finalization to other game object instances, delete spawned
                objects
                or release user input focus (see `release_input_focus`).
            </summary>
        </member>
        <member name="M:support.GUIScript`1.update(System.Single)">
            <summary>
                Called every frame to update the script component.
                This is a callback-function, which is called by the engine every frame to update the state of a script component.
                It can be used to perform any kind of game related tasks, e.g. moving the game object instance.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.GUIScript`1.fixed_update(System.Single)">
            <summary>
                Called every frame to update the script component.
                Frame-rate independent update. dt contains the delta time since the last update.
                Useful when you wish to manipulate physics objects at regular intervals to achieve a stable physics simulation.
                Requires that `physics.use_fixed_timestep` is enabled in game.project.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.GUIScript`1.on_message(types.Hash,System.Object,types.Hash)">
            <summary>
                Called when a message has been sent to the script component.
                This is a callback-function, which is called by the engine whenever a message has been sent to the script
                component.
                It can be used to take action on the message, e.g. send a response back to the sender of the message.
                The `message` parameter is a table containing the message data. If the message is sent from the engine, the
                documentation of the message specifies which data is supplied.
            </summary>
            <param name="message_id">id of the received message</param>
            <param name="message">a table containing the message data</param>
            <param name="sender">address of the sender</param>
        </member>
        <member name="M:support.GUIScript`1.on_input(types.Hash,System.Object)">
            <summary>
                Called when user input is received.
                This is a callback-function, which is called by the engine when user input is sent to the game object instance of
                the script.
                It can be used to take action on the input, e.g. move the instance according to the input.
                For an instance to obtain user input, it must first acquire input focuse through the message `acquire_input_focus`.
                See the documentation of that message for more information.
                The `action` parameter is a table containing data about the input mapped to the `action_id`.
                For mapped actions it specifies the value of the input and if it was just pressed or released.
                Actions are mapped to input in an input_binding-file.
                Mouse movement is specifically handled and uses `nil` as its `action_id`.
                The `action` only contains positional parameters in this case, such as x and y of the pointer.
            </summary>
            <param name="action_id">id of the received input action, as mapped in the input_binding-file</param>
            <param name="action">a table containing the input data, see above for a description</param>
            <returns>boolean to signal if the input should be consumed (not passed on to others) or not, default is false</returns>
        </member>
        <member name="M:support.GUIScript`1.on_reload">
            <summary>
                Called when the script component is reloaded.
                This is a callback-function, which is called by the engine when the script component is reloaded, e.g. from the
                editor.
                It can be used for live development, e.g. to tweak constants or set up the state properly for the instance.
            </summary>
        </member>
        <member name="M:support.GUIScript`1.GetNode(types.Hash)">
            <summary>
            @CSharpLua.Template = "gui.get_node({0})"
            </summary>
        </member>
        <member name="T:support.AnimatableProperties">
            <summary>
                Because Defold will establish properties on the self userobject, we have to create a proxy to source the properties
                from.
            </summary>
        </member>
        <member name="T:support.InputHelpers">
            <summary>
                @CSharpLua.Ignore
            </summary>
        </member>
        <member name="M:support.InputHelpers.RequestInput">
            <summary>
                @CSharpLua.Template = "msg.post('.', 'acquire_input_focus')"
            </summary>
        </member>
        <member name="M:support.InputHelpers.ReleaseInput">
            <summary>
                @CSharpLua.Template = "msg.post('.', 'release_input_focus')"
            </summary>
        </member>
        <member name="M:support.LuaTableSerializableExt.ReturnTable">
            <summary>
                @CSharpLua.Template = table
            </summary>
        </member>
        <member name="T:support.RenderScript`1">
            <summary>
                Base class for all render scripts (render_script). Run by the rendering pipeline and containing the logic required to render all app/game graphics each frame. Render scripts have access to the Render library functions.
            </summary>
        </member>
        <member name="M:support.RenderScript`1.init">
            <summary>
                Called when a script component is initialized.
                This is a callback-function, which is called by the engine when a script component is initialized. It can be used
                to set the initial state of the script.
            </summary>
        </member>
        <member name="M:support.RenderScript`1.final">
            <summary>
                Called when a script component is finalized.
                This is a callback-function, which is called by the engine when a script component is finalized (destroyed). It can
                be used to e.g. take some last action, report the finalization to other game object instances, delete spawned
                objects
                or release user input focus (see `release_input_focus`).
            </summary>
        </member>
        <member name="M:support.RenderScript`1.update(System.Single)">
            <summary>
                Called every frame to update the script component.
                This is a callback-function, which is called by the engine every frame to update the state of a script component.
                It can be used to perform any kind of game related tasks, e.g. moving the game object instance.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.RenderScript`1.fixed_update(System.Single)">
            <summary>
                Called every frame to update the script component.
                Frame-rate independent update. dt contains the delta time since the last update.
                Useful when you wish to manipulate physics objects at regular intervals to achieve a stable physics simulation.
                Requires that `physics.use_fixed_timestep` is enabled in game.project.
            </summary>
            <param name="dt">frame update timestep</param>
        </member>
        <member name="M:support.RenderScript`1.on_message(types.Hash,System.Object,types.Hash)">
            <summary>
                Called when a message has been sent to the script component.
                This is a callback-function, which is called by the engine whenever a message has been sent to the script
                component.
                It can be used to take action on the message, e.g. send a response back to the sender of the message.
                The `message` parameter is a table containing the message data. If the message is sent from the engine, the
                documentation of the message specifies which data is supplied.
            </summary>
            <param name="message_id">id of the received message</param>
            <param name="message">a table containing the message data</param>
            <param name="sender">address of the sender</param>
        </member>
        <member name="M:support.RenderScript`1.on_input(types.Hash,System.Object)">
            <summary>
                Called when user input is received.
                This is a callback-function, which is called by the engine when user input is sent to the game object instance of
                the script.
                It can be used to take action on the input, e.g. move the instance according to the input.
                For an instance to obtain user input, it must first acquire input focuse through the message `acquire_input_focus`.
                See the documentation of that message for more information.
                The `action` parameter is a table containing data about the input mapped to the `action_id`.
                For mapped actions it specifies the value of the input and if it was just pressed or released.
                Actions are mapped to input in an input_binding-file.
                Mouse movement is specifically handled and uses `nil` as its `action_id`.
                The `action` only contains positional parameters in this case, such as x and y of the pointer.
            </summary>
            <param name="action_id">id of the received input action, as mapped in the input_binding-file</param>
            <param name="action">a table containing the input data, see above for a description</param>
            <returns>boolean to signal if the input should be consumed (not passed on to others) or not, default is false</returns>
        </member>
        <member name="M:support.RenderScript`1.on_reload">
            <summary>
                Called when the script component is reloaded.
                This is a callback-function, which is called by the engine when the script component is reloaded, e.g. from the
                editor.
                It can be used for live development, e.g. to tweak constants or set up the state properly for the instance.
            </summary>
        </member>
        <member name="T:Sys">
            <summary>
            System API documentation
            
            </summary>
        </member>
        <member name="T:Sys.exit_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.toggle_profile_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.toggle_physics_debug_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.start_record_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.stop_record_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.reboot_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.set_vsync_message">
            <summary>
            </summary>
        </member>
        <member name="T:Sys.set_update_frequency_message">
            <summary>
            </summary>
        </member>
        <member name="M:Sys.save(System.String,lua.LuaTableBase)">
            <summary>
            The table can later be loaded by <code>sys.load</code>.
            Use <code>sys.get_save_file</code> to obtain a valid location for the file.
            Internally, this function uses a workspace buffer sized output file sized 512kb.
            This size reflects the output file size which must not exceed this limit.
            Additionally, the total number of rows that any one table may contain is limited to 65536
            (i.e. a 16 bit range). When tables are used to represent arrays, the values of
            keys are permitted to fall within a 32 bit range, supporting sparse arrays, however
            the limit on the total number of rows remains in effect.
            
            @CSharpLua.Template = "sys.save({0}, {1})"
            </summary>
        </member>
        <member name="M:Sys.load(System.String)">
            <summary>
            If the file exists, it must have been created by <code>sys.save</code> to be loaded.
            
            @CSharpLua.Template = "sys.load({0})"
            </summary>
        </member>
        <member name="M:Sys.get_save_file(System.String,System.String)">
            <summary>
            The save-file path is operating system specific and is typically located under the user's home directory.
            
            @CSharpLua.Template = "sys.get_save_file({0}, {1})"
            </summary>
        </member>
        <member name="M:Sys.get_application_path">
            <summary>
            The path from which the application is run.
            
            @CSharpLua.Template = "sys.get_application_path()"
            </summary>
        </member>
        <member name="M:Sys.get_config(System.String)">
            <summary>
            Get config value from the game.project configuration file.
            In addition to the project file, configuration values can also be passed
            to the runtime as command line arguments with the <code>--config</code> argument.
            
            @CSharpLua.Template = "sys.get_config({0})"
            </summary>
        </member>
        <member name="M:Sys.get_config(System.String,System.String)">
            <summary>
            Get config value from the game.project configuration file with default value
            
            @CSharpLua.Template = "sys.get_config({0}, {1})"
            </summary>
        </member>
        <member name="M:Sys.open_url(System.String)">
            <summary>
            Open URL in default application, typically a browser
            
            @CSharpLua.Template = "sys.open_url({0})"
            </summary>
        </member>
        <member name="M:Sys.open_url(System.String,lua.LuaTableBase)">
            <summary>
            Open URL in default application, typically a browser
            
            @CSharpLua.Template = "sys.open_url({0}, {1})"
            </summary>
        </member>
        <member name="M:Sys.load_resource(System.String,System.String@)">
            <summary>
            Loads a custom resource. Specify the full filename of the resource that you want
            to load. When loaded, the file data is returned as a string.
            If loading fails, the function returns nil plus the error message.
            In order for the engine to include custom resources in the build process, you need
            to specify them in the "custom_resources" key in your "game.project" settings file.
            You can specify single resource files or directories. If a directory is included
            in the resource list, all files and directories in that directory is recursively
            included:
            For example "main/data/,assets/level_data.json".
            
            @CSharpLua.Template = "sys.load_resource({0})"
            </summary>
        </member>
        <member name="M:Sys.get_sys_info">
            <summary>
            Returns a table with system information.
            
            @CSharpLua.Template = "sys.get_sys_info()"
            </summary>
        </member>
        <member name="M:Sys.get_sys_info(lua.LuaTableBase)">
            <summary>
            Returns a table with system information.
            
            @CSharpLua.Template = "sys.get_sys_info({0})"
            </summary>
        </member>
        <member name="M:Sys.get_engine_info">
            <summary>
            Returns a table with engine information.
            
            @CSharpLua.Template = "sys.get_engine_info()"
            </summary>
        </member>
        <member name="M:Sys.get_application_info(System.String)">
            <summary>
            Returns a table with application information for the requested app.
            <span class="icon-ios"></span> On iOS, the <code>app_string</code> is an url scheme for the app that is queried. Your
            game needs to list the schemes that are queried in an <code>LSApplicationQueriesSchemes</code> array
            in a custom "Info.plist".
            <span class="icon-android"></span> On Android, the <code>app_string</code> is the package identifier for the app.
            
            @CSharpLua.Template = "sys.get_application_info({0})"
            </summary>
        </member>
        <member name="M:Sys.get_ifaddrs">
            <summary>
            Returns an array of tables with information on network interfaces.
            
            @CSharpLua.Template = "sys.get_ifaddrs()"
            </summary>
        </member>
        <member name="M:Sys.set_error_handler(System.Action{System.String,System.String,System.String})">
            <summary>
            Set the Lua error handler function.
            The error handler is a function which is called whenever a lua runtime error occurs.
            
            @CSharpLua.Template = "sys.set_error_handler({0})"
            </summary>
        </member>
        <member name="M:Sys.set_connectivity_host(System.String)">
            <summary>
            Sets the host that is used to check for network connectivity against.
            
            @CSharpLua.Template = "sys.set_connectivity_host({0})"
            </summary>
        </member>
        <member name="M:Sys.get_connectivity">
            <summary>
            <span class="icon-ios"></span> <span class="icon-android"></span> Returns the current network connectivity status
            on mobile platforms.
            On desktop, this function always return <code>sys.NETWORK_CONNECTED</code>.
            
            @CSharpLua.Template = "sys.get_connectivity()"
            </summary>
        </member>
        <member name="M:Sys.exit(System.Double)">
            <summary>
            Terminates the game application and reports the specified <code>code</code> to the OS.
            
            @CSharpLua.Template = "sys.exit({0})"
            </summary>
        </member>
        <member name="M:Sys.reboot(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Reboots the game engine with a specified set of arguments.
            Arguments will be translated into command line arguments. Calling reboot
            function is equivalent to starting the engine with the same arguments.
            On startup the engine reads configuration from "game.project" in the
            project root.
            
            @CSharpLua.Template = "sys.reboot({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Sys.set_vsync_swap_interval(System.Double)">
            <summary>
            Set the vsync swap interval. The interval with which to swap the front and back buffers
            in sync with vertical blanks (v-blank), the hardware event where the screen image is updated
            with data from the front buffer. A value of 1 swaps the buffers at every v-blank, a value of
            2 swaps the buffers every other v-blank and so on. A value of 0 disables waiting for v-blank
            before swapping the buffers. Default value is 1.
            When setting the swap interval to 0 and having <code>vsync</code> disabled in
            "game.project", the engine will try to respect the set frame cap value from
            "game.project" in software instead.
            This setting may be overridden by driver settings.
            
            @CSharpLua.Template = "sys.set_vsync_swap_interval({0})"
            </summary>
        </member>
        <member name="M:Sys.set_update_frequency(System.Double)">
            <summary>
            Set game update-frequency (frame cap). This option is equivalent to <code>display.update_frequency</code> in
            the "game.project" settings but set in run-time. If <code>Vsync</code> checked in "game.project", the rate will
            be clamped to a swap interval that matches any detected main monitor refresh rate. If <code>Vsync</code> is
            unchecked the engine will try to respect the rate in software using timers. There is no
            guarantee that the frame cap will be achieved depending on platform specifics and hardware settings.
            
            @CSharpLua.Template = "sys.set_update_frequency({0})"
            </summary>
        </member>
        <member name="M:Sys.serialize(lua.LuaTableBase)">
            <summary>
            The buffer can later deserialized by <code>sys.deserialize</code>.
            This method has all the same limitations as <code>sys.save</code>.
            
            @CSharpLua.Template = "sys.serialize({0})"
            </summary>
        </member>
        <member name="M:Sys.deserialize(System.String)">
            <summary>
            deserializes buffer into a lua table
            
            @CSharpLua.Template = "sys.deserialize({0})"
            </summary>
        </member>
        <member name="T:Tilemap">
            <summary>
            Tilemap API documentation
            
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(System.String,System.String,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(System.String,System.String,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(System.String,types.Hash,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(System.String,types.Hash,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Hash,System.String,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Hash,System.String,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Hash,types.Hash,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Hash,types.Hash,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Url,System.String,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Url,System.String,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Url,types.Hash,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4})"
            </summary>
        </member>
        <member name="M:Tilemap.set_tile(types.Url,types.Hash,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Replace a tile in a tile map with a new tile.
            The coordinates of the tiles are indexed so that the "first" tile just
            above and to the right of origin has coordinates 1,1.
            Tiles to the left of and below origin are indexed 0, -1, -2 and so forth.
            <pre>
            +-------+-------+------+------+
            |  0,3  |  1,3  | 2,3  | 3,3  |
            +-------+-------+------+------+
            |  0,2  |  1,2  | 2,2  | 3,2  |
            +-------+-------+------+------+
            |  0,1  |  1,1  | 2,1  | 3,1  |
            +-------O-------+------+------+
            |  0,0  |  1,0  | 2,0  | 3,0  |
            +-------+-------+------+------+
            </pre>
            The coordinates must be within the bounds of the tile map as it were created.
            That is, it is not possible to extend the size of a tile map by setting tiles outside the edges.
            To clear a tile, set the tile to number 0. Which tile map and layer to manipulate is identified by the URL and the layer name parameters.
            Transform bitmask is arithmetic sum of one or both FLIP constants (<code>tilemap.H_FLIP</code>, <code>tilemap.V_FLIP</code>) and/or one of ROTATION constants
            (<code>tilemap.ROTATE_90</code>, <code>tilemap.ROTATE_180</code>, <code>tilemap.ROTATE_270</code>).
            Flip always applies before rotation (clockwise).
            
            @CSharpLua.Template = "tilemap.set_tile({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(System.String,System.String,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(System.String,types.Hash,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(types.Hash,System.String,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(types.Hash,types.Hash,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(types.Url,System.String,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_tile(types.Url,types.Hash,System.Double,System.Double)">
            <summary>
            Get the tile set at the specified position in the tilemap.
            The position is identified by the tile index starting at origin
            with index 1, 1. (see <a href="/ref/tilemap#tilemap.set_tile()">tilemap.set_tile()</a>)
            Which tile map and layer to query is identified by the URL and the
            layer name parameters.
            
            @CSharpLua.Template = "tilemap.get_tile({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Tilemap.get_bounds(System.String,System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the bounds for a tile map. This function returns multiple values:
            The lower left corner index x and y coordinates (1-indexed),
            the tile map width and the tile map height.
            The resulting values take all tile map layers into account, meaning that
            the bounds are calculated as if all layers were collapsed into one.
            
            @CSharpLua.Template = "tilemap.get_bounds({0})"
            </summary>
        </member>
        <member name="M:Tilemap.get_bounds(types.Hash,System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the bounds for a tile map. This function returns multiple values:
            The lower left corner index x and y coordinates (1-indexed),
            the tile map width and the tile map height.
            The resulting values take all tile map layers into account, meaning that
            the bounds are calculated as if all layers were collapsed into one.
            
            @CSharpLua.Template = "tilemap.get_bounds({0})"
            </summary>
        </member>
        <member name="M:Tilemap.get_bounds(types.Url,System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the bounds for a tile map. This function returns multiple values:
            The lower left corner index x and y coordinates (1-indexed),
            the tile map width and the tile map height.
            The resulting values take all tile map layers into account, meaning that
            the bounds are calculated as if all layers were collapsed into one.
            
            @CSharpLua.Template = "tilemap.get_bounds({0})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(System.String,System.String,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(System.String,types.Hash,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(types.Hash,System.String,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(types.Hash,types.Hash,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(types.Url,System.String,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Tilemap.set_visible(types.Url,types.Hash,System.Boolean)">
            <summary>
            Sets the visibility of the tilemap layer
            
            @CSharpLua.Template = "tilemap.set_visible({0}, {1}, {2})"
            </summary>
        </member>
        <member name="P:Tilemap.Bounds">
            <summary>
                Gets the bounds for the tilemap.  Allocates memory, so use sparingly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Tilemap.GetBounds(System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Fetches the bounds without allocating memory
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="T:Timer">
            <summary>
            Timer API documentation
            
            </summary>
        </member>
        <member name="M:Timer.delay(System.Double,System.Boolean,System.Action{System.Object,types.Hash,System.Double})">
            <summary>
            Adds a timer and returns a unique handle
            You may create more timers from inside a timer callback.
            Using a delay of 0 will result in a timer that triggers at the next frame just before
            script update functions.
            If you want a timer that triggers on each frame, set delay to 0.0f and repeat to true.
            Timers created within a script will automatically die when the script is deleted.
            
            @CSharpLua.Template = "timer.delay({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Timer.cancel(types.Hash)">
            <summary>
            You may cancel a timer from inside a timer callback.
            Cancelling a timer that is already executed or cancelled is safe.
            
            @CSharpLua.Template = "timer.cancel({0})"
            </summary>
        </member>
        <member name="M:Timer.trigger(types.Hash)">
            <summary>
            Manual triggering a callback for a timer.
            
            @CSharpLua.Template = "timer.trigger({0})"
            </summary>
        </member>
        <member name="T:Vmath">
            <summary>
            Vector math API documentation
            
            </summary>
        </member>
        <member name="M:Vmath.vector3">
            <summary>
            Creates a new zero vector with all components set to 0.
            
            @CSharpLua.Template = "vmath.vector3()"
            </summary>
        </member>
        <member name="M:Vmath.vector3(System.Double)">
            <summary>
            Creates a new vector with all components set to the
            supplied scalar value.
            
            @CSharpLua.Template = "vmath.vector3({0})"
            </summary>
        </member>
        <member name="M:Vmath.vector3(types.vector3)">
            <summary>
            Creates a new vector with all components set to the
            corresponding values from the supplied vector. I.e.
            This function creates a copy of the given vector.
            
            @CSharpLua.Template = "vmath.vector3({0})"
            </summary>
        </member>
        <member name="M:Vmath.vector3(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with the components set to the
            supplied values.
            
            @CSharpLua.Template = "vmath.vector3({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.vector4">
            <summary>
            Creates a new zero vector with all components set to 0.
            
            @CSharpLua.Template = "vmath.vector4()"
            </summary>
        </member>
        <member name="M:Vmath.vector4(System.Double)">
            <summary>
            Creates a new vector with all components set to the
            supplied scalar value.
            
            @CSharpLua.Template = "vmath.vector4({0})"
            </summary>
        </member>
        <member name="M:Vmath.vector4(types.vector4)">
            <summary>
            Creates a new vector with all components set to the
            corresponding values from the supplied vector. I.e.
            This function creates a copy of the given vector.
            
            @CSharpLua.Template = "vmath.vector4({0})"
            </summary>
        </member>
        <member name="M:Vmath.vector4(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with the components set to the
            supplied values.
            
            @CSharpLua.Template = "vmath.vector4({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Vmath.quat">
            <summary>
            Creates a new identity quaternion. The identity
            quaternion is equal to:
            <code>vmath.quat(0, 0, 0, 1)</code>
            
            @CSharpLua.Template = "vmath.quat()"
            </summary>
        </member>
        <member name="M:Vmath.quat(types.Quaternion)">
            <summary>
            Creates a new quaternion with all components set to the
            corresponding values from the supplied quaternion. I.e.
            This function creates a copy of the given quaternion.
            
            @CSharpLua.Template = "vmath.quat({0})"
            </summary>
        </member>
        <member name="M:Vmath.quat(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new quaternion with the components set
            according to the supplied parameter values.
            
            @CSharpLua.Template = "vmath.quat({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Vmath.quat_from_to(types.vector3,types.vector3)">
            <summary>
            The resulting quaternion describes the rotation that,
            if applied to the first vector, would rotate the first
            vector to the second. The two vectors must be unit
            vectors (of length 1).
            <span class="icon-attention"></span> The result is undefined if the two vectors point in opposite directions
            
            @CSharpLua.Template = "vmath.quat_from_to({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.quat_axis_angle(types.vector3,System.Double)">
            <summary>
            The resulting quaternion describes a rotation of <code>angle</code>
            radians around the axis described by the unit vector <code>v</code>.
            
            @CSharpLua.Template = "vmath.quat_axis_angle({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.quat_basis(types.vector3,types.vector3,types.vector3)">
            <summary>
            The resulting quaternion describes the rotation from the
            identity quaternion (no rotation) to the coordinate system
            as described by the given x, y and z base unit vectors.
            
            @CSharpLua.Template = "vmath.quat_basis({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.quat_rotation_x(System.Double)">
            <summary>
            The resulting quaternion describes a rotation of <code>angle</code>
            radians around the x-axis.
            
            @CSharpLua.Template = "vmath.quat_rotation_x({0})"
            </summary>
        </member>
        <member name="M:Vmath.quat_rotation_y(System.Double)">
            <summary>
            The resulting quaternion describes a rotation of <code>angle</code>
            radians around the y-axis.
            
            @CSharpLua.Template = "vmath.quat_rotation_y({0})"
            </summary>
        </member>
        <member name="M:Vmath.quat_rotation_z(System.Double)">
            <summary>
            The resulting quaternion describes a rotation of <code>angle</code>
            radians around the z-axis.
            
            @CSharpLua.Template = "vmath.quat_rotation_z({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4">
            <summary>
            The resulting identity matrix describes a transform with
            no translation or rotation.
            
            @CSharpLua.Template = "vmath.matrix4()"
            </summary>
        </member>
        <member name="M:Vmath.matrix4(types.Matrix4)">
            <summary>
            Creates a new matrix with all components set to the
            corresponding values from the supplied matrix. I.e.
            the function creates a copy of the given matrix.
            
            @CSharpLua.Template = "vmath.matrix4({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_frustum(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a frustum matrix from the given values. The left, right,
            top and bottom coordinates of the view cone are expressed as distances
            from the center of the near clipping plane. The near and far coordinates
            are expressed as distances from the tip of the view frustum cone.
            
            @CSharpLua.Template = "vmath.matrix4_frustum({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_look_at(types.vector3,types.vector3,types.vector3)">
            <summary>
            The resulting matrix is created from the supplied look-at parameters.
            This is useful for constructing a view matrix for a camera or
            rendering in general.
            
            @CSharpLua.Template = "vmath.matrix4_look_at({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_orthographic(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an orthographic projection matrix.
            This is useful to construct a projection matrix for a camera or rendering in general.
            
            @CSharpLua.Template = "vmath.matrix4_orthographic({0}, {1}, {2}, {3}, {4}, {5})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_perspective(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a perspective projection matrix.
            This is useful to construct a projection matrix for a camera or rendering in general.
            
            @CSharpLua.Template = "vmath.matrix4_perspective({0}, {1}, {2}, {3})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_from_quat(types.Quaternion)">
            <summary>
            The resulting matrix describes the same rotation as the quaternion, but does not have any translation (also like the quaternion).
            
            @CSharpLua.Template = "vmath.matrix4_from_quat({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_axis_angle(types.vector3,System.Double)">
            <summary>
            The resulting matrix describes a rotation around the axis by the specified angle.
            
            @CSharpLua.Template = "vmath.matrix4_axis_angle({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_rotation_x(System.Double)">
            <summary>
            The resulting matrix describes a rotation around the x-axis
            by the specified angle.
            
            @CSharpLua.Template = "vmath.matrix4_rotation_x({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_rotation_y(System.Double)">
            <summary>
            The resulting matrix describes a rotation around the y-axis
            by the specified angle.
            
            @CSharpLua.Template = "vmath.matrix4_rotation_y({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_rotation_z(System.Double)">
            <summary>
            The resulting matrix describes a rotation around the z-axis
            by the specified angle.
            
            @CSharpLua.Template = "vmath.matrix4_rotation_z({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_translation(types.vector3)">
            <summary>
            The resulting matrix describes a translation of a point
            in euclidean space.
            
            @CSharpLua.Template = "vmath.matrix4_translation({0})"
            </summary>
        </member>
        <member name="M:Vmath.matrix4_translation(types.vector4)">
            <summary>
            The resulting matrix describes a translation of a point
            in euclidean space.
            
            @CSharpLua.Template = "vmath.matrix4_translation({0})"
            </summary>
        </member>
        <member name="M:Vmath.inv(types.Matrix4)">
            <summary>
            The resulting matrix is the inverse of the supplied matrix.
            <span class="icon-attention"></span> For ortho-normal matrices, e.g. regular object transformation,
            use <code>vmath.ortho_inv()</code> instead.
            The specialized inverse for ortho-normalized matrices is much faster
            than the general inverse.
            
            @CSharpLua.Template = "vmath.inv({0})"
            </summary>
        </member>
        <member name="M:Vmath.ortho_inv(types.Matrix4)">
            <summary>
            The resulting matrix is the inverse of the supplied matrix.
            The supplied matrix has to be an ortho-normal matrix, e.g.
            describe a regular object transformation.
            <span class="icon-attention"></span> For matrices that are not ortho-normal
            use the general inverse <code>vmath.inv()</code> instead.
            
            @CSharpLua.Template = "vmath.ortho_inv({0})"
            </summary>
        </member>
        <member name="M:Vmath.dot(types.vector3,types.vector3)">
            <summary>
            The returned value is a scalar defined as:
            <code>P &#x22C5; Q = |P| |Q| cos &#x03B8;</code>
            where &#x03B8; is the angle between the vectors P and Q.
            <ul>
            <li>If the dot product is positive then the angle between the vectors is below 90 degrees.</li>
            <li>If the dot product is zero the vectors are perpendicular (at right-angles to each other).</li>
            <li>If the dot product is negative then the angle between the vectors is more than 90 degrees.</li>
            </ul>
            
            @CSharpLua.Template = "vmath.dot({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.dot(types.vector3,types.vector4)">
            <summary>
            The returned value is a scalar defined as:
            <code>P &#x22C5; Q = |P| |Q| cos &#x03B8;</code>
            where &#x03B8; is the angle between the vectors P and Q.
            <ul>
            <li>If the dot product is positive then the angle between the vectors is below 90 degrees.</li>
            <li>If the dot product is zero the vectors are perpendicular (at right-angles to each other).</li>
            <li>If the dot product is negative then the angle between the vectors is more than 90 degrees.</li>
            </ul>
            
            @CSharpLua.Template = "vmath.dot({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.dot(types.vector4,types.vector3)">
            <summary>
            The returned value is a scalar defined as:
            <code>P &#x22C5; Q = |P| |Q| cos &#x03B8;</code>
            where &#x03B8; is the angle between the vectors P and Q.
            <ul>
            <li>If the dot product is positive then the angle between the vectors is below 90 degrees.</li>
            <li>If the dot product is zero the vectors are perpendicular (at right-angles to each other).</li>
            <li>If the dot product is negative then the angle between the vectors is more than 90 degrees.</li>
            </ul>
            
            @CSharpLua.Template = "vmath.dot({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.dot(types.vector4,types.vector4)">
            <summary>
            The returned value is a scalar defined as:
            <code>P &#x22C5; Q = |P| |Q| cos &#x03B8;</code>
            where &#x03B8; is the angle between the vectors P and Q.
            <ul>
            <li>If the dot product is positive then the angle between the vectors is below 90 degrees.</li>
            <li>If the dot product is zero the vectors are perpendicular (at right-angles to each other).</li>
            <li>If the dot product is negative then the angle between the vectors is more than 90 degrees.</li>
            </ul>
            
            @CSharpLua.Template = "vmath.dot({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.length_sqr(types.vector3)">
            <summary>
            Returns the squared length of the supplied vector or quaternion.
            
            @CSharpLua.Template = "vmath.length_sqr({0})"
            </summary>
        </member>
        <member name="M:Vmath.length_sqr(types.vector4)">
            <summary>
            Returns the squared length of the supplied vector or quaternion.
            
            @CSharpLua.Template = "vmath.length_sqr({0})"
            </summary>
        </member>
        <member name="M:Vmath.length_sqr(types.Quaternion)">
            <summary>
            Returns the squared length of the supplied vector or quaternion.
            
            @CSharpLua.Template = "vmath.length_sqr({0})"
            </summary>
        </member>
        <member name="M:Vmath.length(types.vector3)">
            <summary>
            Returns the length of the supplied vector or quaternion.
            If you are comparing the lengths of vectors or quaternions, you should compare
            the length squared instead as it is slightly more efficient to calculate
            (it eliminates a square root calculation).
            
            @CSharpLua.Template = "vmath.length({0})"
            </summary>
        </member>
        <member name="M:Vmath.length(types.vector4)">
            <summary>
            Returns the length of the supplied vector or quaternion.
            If you are comparing the lengths of vectors or quaternions, you should compare
            the length squared instead as it is slightly more efficient to calculate
            (it eliminates a square root calculation).
            
            @CSharpLua.Template = "vmath.length({0})"
            </summary>
        </member>
        <member name="M:Vmath.length(types.Quaternion)">
            <summary>
            Returns the length of the supplied vector or quaternion.
            If you are comparing the lengths of vectors or quaternions, you should compare
            the length squared instead as it is slightly more efficient to calculate
            (it eliminates a square root calculation).
            
            @CSharpLua.Template = "vmath.length({0})"
            </summary>
        </member>
        <member name="M:Vmath.normalize(types.vector3)">
            <summary>
            Normalizes a vector, i.e. returns a new vector with the same
            direction as the input vector, but with length 1.
            <span class="icon-attention"></span> The length of the vector must be above 0, otherwise a
            division-by-zero will occur.
            
            @CSharpLua.Template = "vmath.normalize({0})"
            </summary>
        </member>
        <member name="M:Vmath.normalize(types.vector4)">
            <summary>
            Normalizes a vector, i.e. returns a new vector with the same
            direction as the input vector, but with length 1.
            <span class="icon-attention"></span> The length of the vector must be above 0, otherwise a
            division-by-zero will occur.
            
            @CSharpLua.Template = "vmath.normalize({0})"
            </summary>
        </member>
        <member name="M:Vmath.normalize(types.Quaternion)">
            <summary>
            Normalizes a vector, i.e. returns a new vector with the same
            direction as the input vector, but with length 1.
            <span class="icon-attention"></span> The length of the vector must be above 0, otherwise a
            division-by-zero will occur.
            
            @CSharpLua.Template = "vmath.normalize({0})"
            </summary>
        </member>
        <member name="M:Vmath.cross(types.vector3,types.vector3)">
            <summary>
            Given two linearly independent vectors P and Q, the cross product,
            P &#x00D7; Q, is a vector that is perpendicular to both P and Q and
            therefore normal to the plane containing them.
            If the two vectors have the same direction (or have the exact
            opposite direction from one another, i.e. are not linearly independent)
            or if either one has zero length, then their cross product is zero.
            
            @CSharpLua.Template = "vmath.cross({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.lerp(System.Double,types.vector3,types.vector3)">
            <summary>
            Linearly interpolate between two vectors. The function
            treats the vectors as positions and interpolates between
            the positions in a straight line. Lerp is useful to describe
            transitions from one place to another over time.
            <span class="icon-attention"></span> The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.lerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.lerp(System.Double,types.vector4,types.vector4)">
            <summary>
            Linearly interpolate between two vectors. The function
            treats the vectors as positions and interpolates between
            the positions in a straight line. Lerp is useful to describe
            transitions from one place to another over time.
            <span class="icon-attention"></span> The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.lerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.lerp(System.Double,types.Quaternion,types.Quaternion)">
            <summary>
            Linearly interpolate between two vectors. The function
            treats the vectors as positions and interpolates between
            the positions in a straight line. Lerp is useful to describe
            transitions from one place to another over time.
            <span class="icon-attention"></span> The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.lerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.lerp(System.Double,System.Double,System.Double)">
            <summary>
            Linearly interpolate between two vectors. The function
            treats the vectors as positions and interpolates between
            the positions in a straight line. Lerp is useful to describe
            transitions from one place to another over time.
            <span class="icon-attention"></span> The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.lerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.slerp(System.Double,types.vector3,types.vector3)">
            <summary>
            Spherically interpolates between two vectors. The difference to
            lerp is that slerp treats the vectors as directions instead of
            positions in space.
            The direction of the returned vector is interpolated by the angle
            and the magnitude is interpolated between the magnitudes of the
            from and to vectors.
            <span class="icon-attention"></span> Slerp is computationally more expensive than lerp.
            The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.slerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.slerp(System.Double,types.vector4,types.vector4)">
            <summary>
            Spherically interpolates between two vectors. The difference to
            lerp is that slerp treats the vectors as directions instead of
            positions in space.
            The direction of the returned vector is interpolated by the angle
            and the magnitude is interpolated between the magnitudes of the
            from and to vectors.
            <span class="icon-attention"></span> Slerp is computationally more expensive than lerp.
            The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.slerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.slerp(System.Double,types.Quaternion,types.Quaternion)">
            <summary>
            Spherically interpolates between two vectors. The difference to
            lerp is that slerp treats the vectors as directions instead of
            positions in space.
            The direction of the returned vector is interpolated by the angle
            and the magnitude is interpolated between the magnitudes of the
            from and to vectors.
            <span class="icon-attention"></span> Slerp is computationally more expensive than lerp.
            The function does not clamp t between 0 and 1.
            
            @CSharpLua.Template = "vmath.slerp({0}, {1}, {2})"
            </summary>
        </member>
        <member name="M:Vmath.conj(types.Quaternion)">
            <summary>
            Calculates the conjugate of a quaternion. The result is a
            quaternion with the same magnitudes but with the sign of
            the imaginary (vector) parts changed:
            <code>q<super>*</super> = [w, -v]</code>
            
            @CSharpLua.Template = "vmath.conj({0})"
            </summary>
        </member>
        <member name="M:Vmath.rotate(types.Quaternion,types.vector3)">
            <summary>
            Returns a new vector from the supplied vector that is
            rotated by the rotation described by the supplied
            quaternion.
            
            @CSharpLua.Template = "vmath.rotate({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.project(types.vector3,types.vector3)">
            <summary>
            Calculates the extent the projection of the first vector onto the second.
            The returned value is a scalar p defined as:
            <code>p = |P| cos &#x03B8; / |Q|</code>
            where &#x03B8; is the angle between the vectors P and Q.
            
            @CSharpLua.Template = "vmath.project({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.mul_per_elem(types.vector3,types.vector3)">
            <summary>
            Performs an element wise multiplication between two vectors of the same type
            The returned value is a vector defined as (e.g. for a vector3):
            <code>v = vmath.mul_per_elem(a, b) = vmath.vector3(a.x * b.x, a.y * b.y, a.z * b.z)</code>
            
            @CSharpLua.Template = "vmath.mul_per_elem({0}, {1})"
            </summary>
        </member>
        <member name="M:Vmath.mul_per_elem(types.vector4,types.vector4)">
            <summary>
            Performs an element wise multiplication between two vectors of the same type
            The returned value is a vector defined as (e.g. for a vector3):
            <code>v = vmath.mul_per_elem(a, b) = vmath.vector3(a.x * b.x, a.y * b.y, a.z * b.z)</code>
            
            @CSharpLua.Template = "vmath.mul_per_elem({0}, {1})"
            </summary>
        </member>
        <member name="T:Webview">
            <summary>
            Webview API documentation
            
            </summary>
        </member>
        <member name="T:Window">
            <summary>
            Window API documentation
            
            </summary>
        </member>
        <member name="M:Window.set_listener(System.Action{System.Object,types.WindowEvent,lua.LuaTable})">
            <summary>
            Sets a window event listener.
            
            @CSharpLua.Template = "window.set_listener({0})"
            </summary>
        </member>
        <member name="M:Window.set_mouse_lock(System.Boolean)">
            <summary>
            Set the locking state for current mouse cursor on a PC platform.
            This function locks or unlocks the mouse cursor to the center point of the window. While the cursor is locked,
            mouse position updates will still be sent to the scripts as usual.
            
            @CSharpLua.Template = "window.set_mouse_lock({0})"
            </summary>
        </member>
        <member name="M:Window.set_dim_mode(types.WindowDimming)">
            <summary>
            <span class="icon-ios"></span> <span class="icon-android"></span> Sets the dimming mode on a mobile device.
            The dimming mode specifies whether or not a mobile device should dim the screen after a period without user interaction. The dimming mode will only affect the mobile device while the game is in focus on the device, but not when the game is running in the background.
            This function has no effect on platforms that does not support dimming.
            
            @CSharpLua.Template = "window.set_dim_mode({0})"
            </summary>
        </member>
        <member name="M:Window.get_dim_mode">
            <summary>
            <span class="icon-ios"></span> <span class="icon-android"></span> Returns the current dimming mode set on a mobile device.
            The dimming mode specifies whether or not a mobile device should dim the screen after a period without user interaction.
            On platforms that does not support dimming, <code>window.DIMMING_UNKNOWN</code> is always returned.
            
            @CSharpLua.Template = "window.get_dim_mode()"
            </summary>
        </member>
        <member name="M:Window.get_size(System.Double@)">
            <summary>
            This returns the current window size (width and height).
            
            @CSharpLua.Template = "window.get_size()"
            </summary>
        </member>
        <member name="M:Window.get_mouse_lock">
            <summary>
            This returns the current lock state of the mouse cursor
            
            @CSharpLua.Template = "window.get_mouse_lock()"
            </summary>
        </member>
        <member name="T:Zlib">
            <summary>
            Zlib compression API documentation
            
            </summary>
        </member>
        <member name="M:Zlib.inflate(System.String)">
            <summary>
            A lua error is raised is on error
            
            @CSharpLua.Template = "zlib.inflate({0})"
            </summary>
        </member>
        <member name="M:Zlib.deflate(System.String)">
            <summary>
            A lua error is raised is on error
            
            @CSharpLua.Template = "zlib.deflate({0})"
            </summary>
        </member>
    </members>
</doc>
